{
  "hash": "9f15cea1b9013511409dea0e239d86c2",
  "result": {
    "markdown": "---\ntitle: \"Robotics and Automation\"\ncategories: [Robotics]\nimage: ../images/Robotics.gif \nformat:\n    html: \n        code-fold: true\n        code-overflow: scroll\n        code-tools: true\n\n---\n\n## Inverse Kinematics Optimazation\n\nWe are building a snake robot. This snake robot moves in a plane and has 5 joints, making it a redundant robot. We are using this redundancy to mimic the motion of real snakes.\n\n![](Images/Inv_diagram.png){fig-align=\"center\" width=30%} \n\nLeaving ùëè = 0 within the Jacobian pseudoinverse. Implementing the numerical inverse kinematics algorithm to find the inverse kinematics solutions when:\n\n* **Case 1: ùêø = 1 and the desired end-effector pose is:**\n\n**Tsb = [rotz(pi/4), [3;2;0]; 0 0 0 1]**\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.animation as animation\nfrom matplotlib.animation import PillowWriter\n\n# Define the necessary functions\ndef bracket3(S):\n    return np.array([[0, -S[2], S[1]], [S[2], 0, -S[0]], [-S[1], S[0], 0]])\n\ndef expm(A):\n    return np.linalg.matrix_power(np.eye(A.shape[0]) + A / 16, 16)\n\ndef adjointM(T):\n    R = T[0:3, 0:3]\n    p = T[0:3, 3]\n    return np.block([[R, np.zeros((3, 3))], [bracket3(p) @ R, R]])\n\ndef r2axisangle(R):\n    if np.linalg.norm(R - np.eye(3)) < 1e-3:\n        return np.array([0, 0, 0])\n    else:\n        theta = np.arccos(0.5 * (np.trace(R) - 1))\n        omega_hat = 1 / (2 * np.sin(theta)) * (R - R.T)\n        omega = np.array([omega_hat[2, 1], omega_hat[0, 2], omega_hat[1, 0]])\n        return omega * theta\n\ndef bracket_s(s):\n    return np.array([[0, -s[2], s[1], s[3]], [s[2], 0, -s[0], s[4]], [-s[1], s[0], 0, s[5]], [0, 0, 0, 0]])\n\ndef fk(M, S, theta):\n    T = np.eye(4)\n    theta = np.atleast_1d(theta)\n    for i in range(len(theta)):\n        T = np.dot(T, expm(bracket_s(S[:, i]) * theta[i]))\n    return np.dot(T, M)\n\ndef JacS(S, theta):\n    T = np.eye(4)\n    Js = np.zeros((6, len(theta)))\n    for i in range(len(theta)):\n        Si = S[:, i]\n        Js[:, i] = adjointM(T) @ Si\n        T = np.dot(T, expm(bracket_s(Si) * theta[i]))\n    return Js\n\ndef rotz(angle):\n    c, s = np.cos(angle), np.sin(angle)\n    return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n# Initialize plot\nfig, ax = plt.subplots()\nax.set_xlim(-6, 6)\nax.set_ylim(-6, 6)\nax.grid(True)\nline, = ax.plot([], [], 'o-', color=[1, 0.5, 0], linewidth=4)\nplt.ion()\n\n# Initialize parameters\nL = 1\ntheta = np.array([np.pi/8] * 5)\n\nS1 = np.array([0, 0, 1, 0, 0, 0])\nS2 = np.array([0, 0, 1, 0, -1 * L, 0])\nS3 = np.array([0, 0, 1, 0, -2 * L, 0])\nS4 = np.array([0, 0, 1, 0, -3 * L, 0])\nS5 = np.array([0, 0, 1, 0, -4 * L, 0])\n\n# Create S_eq by concatenating the individual S vectors horizontally\nS = np.column_stack((S1, S2, S3, S4, S5))\n\nM = np.vstack([np.hstack([np.eye(3), np.array([[5*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM1 = np.vstack([np.hstack([np.eye(3), np.array([[1*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM2 = np.vstack([np.hstack([np.eye(3), np.array([[2*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM3 = np.vstack([np.hstack([np.eye(3), np.array([[3*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM4 = np.vstack([np.hstack([np.eye(3), np.array([[4*L, 0, 0]]).T]), [0, 0, 0, 1]])\n\n# Desired transformation\nT_d = np.vstack([np.hstack([rotz(np.pi/4), np.array([[3, 2, 0]]).T]), [0, 0, 0, 1]])\nXd = np.concatenate([r2axisangle(T_d[0:3, 0:3]), T_d[0:3, 3]])\n\n# Initial forward kinematics\nT = fk(M, S, theta)\nX = np.concatenate([r2axisangle(T[0:3, 0:3]), T[0:3, 3]])\n\n# Animation function\ndef update(frame):\n    global theta, T, X\n    if np.linalg.norm(Xd - X) > 1e-1:\n        # Calculate joint transformations\n        T1 = fk(M1, S[:, 0:1], theta[0])\n        T2 = fk(M2, S[:, 0:2], [theta[0], theta[1]])\n        T3 = fk(M3, S[:, 0:3], [theta[0], theta[1], theta[2]])\n        T4 = fk(M4, S[:, 0:4], [theta[0], theta[1], theta[2], theta[3]])\n        P_v = np.array([[0, 0]] + [T1[0:2, 3]]+ [T2[0:2, 3]]+ [T3[0:2, 3]]+ [T4[0:2, 3]] + [T[0:2, 3]]).T\n        \n        # Draw the robot\n        line.set_data(P_v[0, :], P_v[1, :])\n        \n        # Update Jacobians and compute delta_theta\n        JS = JacS(S, theta)\n        Jb = np.dot(adjointM(np.linalg.inv(T)), JS)\n        J_geometric = np.block([[T[0:3, 0:3], np.zeros((3, 3))], [np.zeros((3, 3)), T[0:3, 0:3]]]) @ Jb\n        V = Xd - X\n        delta_theta = np.dot(np.linalg.pinv(J_geometric), V)\n        \n        # Update theta\n        theta += 0.1 * delta_theta\n        print(theta)\n        T = fk(M, S, theta)\n        X = np.concatenate([r2axisangle(T[0:3, 0:3]), T[0:3, 3]])\n\n    return line,\n\n# Create and save the animation\nani = animation.FuncAnimation(fig, update, frames=np.arange(100), interval=200, blit=False)\n\n# Save the animation\nwriter = PillowWriter(fps=7)  \nani.save(\"Inverse_Kinematics_1.gif\", writer=writer)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.1993027  0.46598915 0.5549693  0.45091411 0.16786868]\n[0.06113478 0.51001426 0.66899306 0.48188162 0.00600057]\n[-0.04783409  0.54015932  0.75714363  0.5007544  -0.12217812]\n[-0.13708095  0.56186278  0.82784958  0.51267239 -0.22751968]\n[-0.21165874  0.57790022  0.88568751  0.52017065 -0.31583542]\n[-0.27477388  0.5899323   0.93358891  0.52472423 -0.39080532]\n[-0.32867117  0.59904312  0.97361294  0.5272736  -0.45499474]\n[-0.37501922  0.60597918  1.00728854  0.52845196 -0.51030329]\n[-0.41510644  0.61127299  1.03579107  0.52869999 -0.55819525]\n[-0.4499529   0.61531389  1.06004448  0.52833026 -0.59983118]\n[-0.48038014  0.61839181  1.08078598  0.52756653 -0.6361495 ]\n[-0.50705787  0.62072567  1.09860977  0.52656924 -0.66792036]\n[-0.53053703  0.62248263  1.11399827  0.52545283 -0.69578303]\n[-0.55127405  0.62379138  1.12734533  0.52429798 -0.7202729 ]\n[-0.5696494   0.62475176  1.13897385  0.52316041 -0.74184164]\n[-0.5859818   0.62544159  1.14914958  0.52207742 -0.76087249]\n[-0.60053959  0.62592179  1.15809195  0.52107267 -0.77769233]\n[-0.61354965  0.62624023  1.16598274  0.52015989 -0.79258114]\n[-0.62520472  0.62643455  1.17297302  0.51934559 -0.80577965]\n[-0.63566914  0.62653443  1.17918872  0.51863112 -0.81749553]\n[-0.64508373  0.62656321  1.18473524  0.51801426 -0.82790846]\n[-0.65356956  0.62653929  1.18970101  0.51749037 -0.83717436]\n[-0.66123122  0.62647712  1.19416061  0.5170533  -0.84542885]\n[-0.66815939  0.62638801  1.19817709  0.51669598 -0.85279014]\n[-0.674433    0.62628077  1.20180402  0.51641096 -0.85936152]\n[-0.68012103  0.62616224  1.2050871   0.5161907  -0.86523342]\n[-0.68528399  0.62603768  1.20806547  0.51602782 -0.87048512]\n[-0.68997511  0.62591108  1.21077282  0.51591529 -0.87518629]\n[-0.69424143  0.62578545  1.21323825  0.51584648 -0.87939821]\n[-0.6981246   0.625663    1.21548703  0.51581529 -0.88317488]\n[-0.70166164  0.62554531  1.21754119  0.51581611 -0.88656397]\n[-0.70488554  0.62543349  1.21942004  0.51584388 -0.88960757]\n[-0.70782576  0.62532823  1.22114053  0.51589405 -0.89234295]\n```\n:::\n:::\n\n\nAt each iteration we first plot the robot and save a video frame. Then we calculate the Jacobian and perform numerical inverse kinematics. The loop terminates when the actual pose is close to the desired pose.\n\n**MATLAB implementation**\n\n<details>\n\n```matlab\n\nclose all\nclear\nclc\n\n% create figure\nfigure\naxis([-6, 6, -6, 6])\ngrid on\nhold on\n\n% save as a video file\nv = VideoWriter('Inverse_Kinematics_1.mp4', 'MPEG-4');\nv.FrameRate = 25;\nopen(v);\n\n% initial joint values\nL = 1;\ntheta = [pi/8; pi/8; pi/8; pi/8; pi/8];\n\nS1 = [0 0 1 0 0 0]';\nS2 = [0 0 1 0 -1*L 0]';\nS3 = [0 0 1 0 -2*L 0]';\nS4 = [0 0 1 0 -3*L 0]';\nS5 = [0 0 1 0 -4*L 0]';\n\nS_eq = [S1, S2, S3, S4, S5];   \nM = [eye(3), [5*L;0;0]; 0 0 0 1];\nM1 = [eye(3), [1*L;0;0]; 0 0 0 1];\nM2 = [eye(3), [2*L;0;0]; 0 0 0 1];\nM3 = [eye(3), [3*L;0;0]; 0 0 0 1];\nM4 = [eye(3), [4*L;0;0]; 0 0 0 1];\n\n% Given desired Transformation matrices T_d\nT_d = [rotz(pi/4), [3;2;0]; 0 0 0 1];\nXd = [r2axisangle(T_d(1:3, 1:3)); T_d(1:3,4)];\n\n% T with initial joint positions\nT = fk(M, S_eq, theta);\nX = [r2axisangle(T(1:3, 1:3)); T(1:3,4)];\n\nwhile norm(Xd - X) > 1e-2\n\n    p0 = [0; 0]; % plot the robot\n    T1 = fk(M1, S1, theta(1)); % 1. get the position of each link\n    T2 = fk(M2, [S1, S2], [theta(1), theta(2)]);\n    T3 = fk(M3, [S1, S2, S3], [theta(1), theta(2), theta(3)]);\n    T4 = fk(M4, [S1, S2, S3, S4], [theta(1), theta(2), theta(3), theta(4)]);\n    P_v = [p0, T1(1:2, 4), T2(1:2, 4), T3(1:2, 4), T4(1:2, 4), T(1:2, 4)];\n\n    cla; % 2. draw the robot and save the frame\n    plot(P_v(1,:), P_v(2,:), 'o-', 'color',[1, 0.5, 0],'linewidth',4)\n    drawnow\n    frame = getframe(gcf);\n    writeVideo(v, frame); % My Implementation for inverse kinematics calculation below\n\n    JS = JacS(S_eq, theta); % Updated Space Jacobian\n    Jb = adjointM(inv(T))*JS; %Updated Body Jacobian\n    J = [T(1:3, 1:3) zeros(3); zeros(3) T(1:3, 1:3)] * Jb; % Updated Geometric Jacobian\n    V = Xd - X;\n\n    delta_theta = pinv(J)*V +(eye(5) - pinv(J)*J)*[0;0;0;0;0];\n\n    theta = double(theta + 0.1 * delta_theta); % Updating theta until the while loop is satisfied to get the desired joint positions\n    T = fk(M, S_eq, theta);\n    X = [r2axisangle(T(1:3, 1:3)); T(1:3,4)];\nend\n\nclose(v);\nclose all\n```\n\n</details>\n\n**Result:**\n\n<img src=\"Inverse_Kinematics_1.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\n\n* **Case 2: ùêø = 1 and the desired end-effector pose is:**\n\n**Tsb = [rotz(pi/2), [-2;4;0]; 0 0 0 1]**\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom matplotlib.animation import PillowWriter\n\n# Define the necessary functions\ndef bracket3(S):\n    return np.array([[0, -S[2], S[1]], [S[2], 0, -S[0]], [-S[1], S[0], 0]])\n\ndef expm(A):\n    return np.linalg.matrix_power(np.eye(A.shape[0]) + A / 16, 16)\n\ndef adjointM(T):\n    R = T[0:3, 0:3]\n    p = T[0:3, 3]\n    return np.block([[R, np.zeros((3, 3))], [bracket3(p) @ R, R]])\n\ndef r2axisangle(R):\n    if np.linalg.norm(R - np.eye(3)) < 1e-3:\n        return np.array([0, 0, 0])\n    else:\n        theta = np.arccos(0.5 * (np.trace(R) - 1))\n        omega_hat = 1 / (2 * np.sin(theta)) * (R - R.T)\n        omega = np.array([omega_hat[2, 1], omega_hat[0, 2], omega_hat[1, 0]])\n        return omega * theta\n\ndef bracket_s(s):\n    return np.array([[0, -s[2], s[1], s[3]], [s[2], 0, -s[0], s[4]], [-s[1], s[0], 0, s[5]], [0, 0, 0, 0]])\n\ndef fk(M, S, theta):\n    T = np.eye(4)\n    theta = np.atleast_1d(theta)\n    for i in range(len(theta)):\n        T = np.dot(T, expm(bracket_s(S[:, i]) * theta[i]))\n    return np.dot(T, M)\n\ndef JacS(S, theta):\n    T = np.eye(4)\n    Js = np.zeros((6, len(theta)))\n    for i in range(len(theta)):\n        Si = S[:, i]\n        Js[:, i] = np.dot(adjointM(T), Si)\n        T = np.dot(T, expm(bracket_s(Si) * theta[i]))\n    return Js\n\ndef rotz(angle):\n    c, s = np.cos(angle), np.sin(angle)\n    return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n# Initialize plot\nfig, ax = plt.subplots()\nax.set_xlim(-6, 6)\nax.set_ylim(-6, 6)\nax.grid(True)\nline, = ax.plot([], [], 'o-', color=[1, 0.5, 0], linewidth=4)\nplt.ion()\n\n# Initialize parameters\nL = 1\ntheta = np.array([np.pi/8] * 5)\n\nS1 = np.array([0, 0, 1, 0, 0, 0])\nS2 = np.array([0, 0, 1, 0, -1 * L, 0])\nS3 = np.array([0, 0, 1, 0, -2 * L, 0])\nS4 = np.array([0, 0, 1, 0, -3 * L, 0])\nS5 = np.array([0, 0, 1, 0, -4 * L, 0])\n\n# Create S_eq by concatenating the individual S vectors horizontally\nS = np.column_stack((S1, S2, S3, S4, S5))\n\nM = np.vstack([np.hstack([np.eye(3), np.array([[5*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM1 = np.vstack([np.hstack([np.eye(3), np.array([[1*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM2 = np.vstack([np.hstack([np.eye(3), np.array([[2*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM3 = np.vstack([np.hstack([np.eye(3), np.array([[3*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM4 = np.vstack([np.hstack([np.eye(3), np.array([[4*L, 0, 0]]).T]), [0, 0, 0, 1]])\n\n# Desired transformation\nT_d = np.vstack([np.hstack([rotz(np.pi/2), np.array([[-2, 4, 0]]).T]), [0, 0, 0, 1]])\nXd = np.concatenate([r2axisangle(T_d[0:3, 0:3]), T_d[0:3, 3]])\n\n# Initial forward kinematics\nT = fk(M, S, theta)\nX = np.concatenate([r2axisangle(T[0:3, 0:3]), T[0:3, 3]])\n\n# Animation function\ndef update(frame):\n    global theta, T, X\n    if np.linalg.norm(Xd - X) > 1e-1:\n        # Calculate joint transformations\n        T1 = fk(M1, S[:, 0:1], theta[0])\n        T2 = fk(M2, S[:, 0:2], [theta[0], theta[1]])\n        T3 = fk(M3, S[:, 0:3], [theta[0], theta[1], theta[2]])\n        T4 = fk(M4, S[:, 0:4], [theta[0], theta[1], theta[2], theta[3]])\n        P_v = np.array([[0, 0]] + [T1[0:2, 3]]+ [T2[0:2, 3]]+ [T3[0:2, 3]]+ [T4[0:2, 3]] + [T[0:2, 3]]).T\n        \n        # Draw the robot\n        line.set_data(P_v[0, :], P_v[1, :])\n        \n        # Update Jacobians and compute delta_theta\n        JS = JacS(S, theta)\n        Jb = np.dot(adjointM(np.linalg.inv(T)), JS)\n        J_geometric = np.block([[T[0:3, 0:3], np.zeros((3, 3))], [np.zeros((3, 3)), T[0:3, 0:3]]]) @ Jb\n        V = Xd - X\n        delta_theta = np.dot(np.linalg.pinv(J_geometric), V)\n        \n        # Update theta\n        theta += 0.1 * delta_theta\n        print(theta)\n        T = fk(M, S, theta)\n        X = np.concatenate([r2axisangle(T[0:3, 0:3]), T[0:3, 3]])\n\n    return line,\n\n# Create and save the animation\nani = animation.FuncAnimation(fig, update, frames=np.arange(100), interval=200, blit=False)\n\n# Save the animation\nwriter = PillowWriter(fps=7)  \nani.save(\"Inverse_Kinematics_2.gif\", writer=writer)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.27558403 0.52539357 0.58147356 0.43337151 0.10176109]\n[ 0.23291267  0.62281115  0.69826779  0.42871219 -0.10691892]\n[ 0.22580829  0.70313343  0.77671288  0.40497409 -0.27382697]\n[ 0.24119701  0.77132002  0.82821562  0.37105773 -0.41150535]\n[ 0.2718153   0.8295479   0.85923151  0.33181449 -0.52627559]\n[ 0.31274707  0.87904332  0.8743584   0.2903601  -0.62219375]\n[ 0.36037301  0.92067736  0.8772505   0.24879702 -0.70229657]\n[ 0.41195291  0.95520389  0.8709295   0.2085294  -0.76907122]\n[ 0.46541083  0.98335279  0.85790084  0.17044848 -0.82464119]\n[ 0.51919361  1.00585499  0.84021288  0.13506709 -0.870841  ]\n[ 0.5721616   1.02343655  0.81950593  0.10262535 -0.90925052]\n[ 0.62349983  1.03680166  0.79706383  0.07317388 -0.94121782]\n[ 0.67264561  1.04661494  0.77386781  0.04663753 -0.96788097]\n[ 0.71923024  1.05348758  0.75064905  0.02286273 -0.99019128]\n[ 0.7630329   1.05796872  0.72793692  0.00165141 -1.00893724]\n[ 0.8039445   1.06054162  0.70610121 -0.01721531 -1.02476784]\n[ 0.84193941  1.06162373  0.68538768 -0.03396117 -1.03821437]\n[ 0.87705364  1.0615696   0.66594718 -0.04880443 -1.04970985]\n[ 0.90936772  1.06067554  0.64785912 -0.06195155 -1.05960604]\n[ 0.93899362  1.05918532  0.63114996 -0.07359367 -1.06818794]\n[ 0.96606452  1.05729631  0.61580777 -0.08390494 -1.07568598]\n[ 0.9907269   1.05516563  0.60179336 -0.09304224 -1.08228624]\n[ 1.01313455  1.05291598  0.58904898 -0.10114556 -1.08813882]\n[ 1.0334439   1.05064118  0.57750482 -0.10833905 -1.09336475]\n[ 1.05181053  1.04841102  0.567084   -0.11473216 -1.09806168]\n[ 1.06838657  1.04627563  0.55770621 -0.12042109 -1.10230846]\n[ 1.08331882  1.04426933  0.5492905  -0.1254901  -1.10616887]\n[ 1.09674737  1.04241382  0.54175722 -0.13001288 -1.10969466]\n[ 1.10880476  1.04072101  0.53502938 -0.13405379 -1.11292799]\n[ 1.1196154   1.03919526  0.52903362 -0.13766903 -1.11590337]\n[ 1.12929533  1.03783535  0.52370084 -0.14090766 -1.11864926]\n[ 1.13795221  1.03663596  0.51896646 -0.14381257 -1.12118929]\n[ 1.14568536  1.03558894  0.51477065 -0.14642125 -1.12354325]\n[ 1.15258609  1.0346843   0.51105826 -0.14876653 -1.12572791]\n[ 1.15873796  1.03391096  0.50777879 -0.15087723 -1.12775764]\n```\n:::\n:::\n\n\n**MATLAB implementation**\n\n<details>\n\n```matlab\n\nclose all\nclear\nclc\n\n% create figure\nfigure\naxis([-6, 6, -6, 6])\ngrid on\nhold on\n\n% save as a video file\nv = VideoWriter('Inverse_Kinematics_2.mp4', 'MPEG-4');\nv.FrameRate = 25;\nopen(v);\n\n% initial joint values\nL = 1;\ntheta = [pi/8; pi/8; pi/8; pi/8; pi/8];\n\nS1 = [0 0 1 0 0 0]';\nS2 = [0 0 1 0 -1*L 0]';\nS3 = [0 0 1 0 -2*L 0]';\nS4 = [0 0 1 0 -3*L 0]';\nS5 = [0 0 1 0 -4*L 0]';\n\nS_eq = [S1, S2, S3, S4, S5];   \nM = [eye(3), [5*L;0;0]; 0 0 0 1];\nM1 = [eye(3), [1*L;0;0]; 0 0 0 1];\nM2 = [eye(3), [2*L;0;0]; 0 0 0 1];\nM3 = [eye(3), [3*L;0;0]; 0 0 0 1];\nM4 = [eye(3), [4*L;0;0]; 0 0 0 1];\n\n% Given desired Transformation matrices T_d\nT_d = [rotz(pi/4), [-2;4;0]; 0 0 0 1];\nXd = [r2axisangle(T_d(1:3, 1:3)); T_d(1:3,4)];\n\n% T with initial joint positions\nT = fk(M, S_eq, theta);\nX = [r2axisangle(T(1:3, 1:3)); T(1:3,4)];\n\nwhile norm(Xd - X) > 1e-2\n\n    p0 = [0; 0]; % plot the robot\n    T1 = fk(M1, S1, theta(1)); % 1. get the position of each link\n    T2 = fk(M2, [S1, S2], [theta(1), theta(2)]);\n    T3 = fk(M3, [S1, S2, S3], [theta(1), theta(2), theta(3)]);\n    T4 = fk(M4, [S1, S2, S3, S4], [theta(1), theta(2), theta(3), theta(4)]);\n    P_v = [p0, T1(1:2, 4), T2(1:2, 4), T3(1:2, 4), T4(1:2, 4), T(1:2, 4)];\n\n    cla; % 2. draw the robot and save the frame\n    plot(P_v(1,:), P_v(2,:), 'o-', 'color',[1, 0.5, 0],'linewidth',4)\n    drawnow\n    frame = getframe(gcf);\n    writeVideo(v, frame); % My Implementation for inverse kinematics calculation below\n\n    JS = JacS(S_eq, theta); % Updated Space Jacobian\n    Jb = adjointM(inv(T))*JS; %Updated Body Jacobian\n    J = [T(1:3, 1:3) zeros(3); zeros(3) T(1:3, 1:3)] * Jb; % Updated Geometric Jacobian\n    V = Xd - X;\n\n    delta_theta = pinv(J)*V +(eye(5) - pinv(J)*J)*[0;0;0;0;0];\n\n    theta = double(theta + 0.1 * delta_theta); % Updating theta until the while loop is satisfied to get the desired joint positions\n    T = fk(M, S_eq, theta);\n    X = [r2axisangle(T(1:3, 1:3)); T(1:3,4)];\nend\n\nclose(v);\nclose all\n```\n\n</details>\n\n**Result:**\n\n<img src=\"Inverse_Kinematics_2.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\n\n* **Case 3: ùêø = 1 and the desired end-effector pose is:**\n\n**Tsb = [rotz(0), [3;-1;0]; 0 0 0 1]**\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom matplotlib.animation import PillowWriter\n\n# Define the necessary functions\ndef bracket3(S):\n    return np.array([[0, -S[2], S[1]], [S[2], 0, -S[0]], [-S[1], S[0], 0]])\n\ndef expm(A):\n    return np.linalg.matrix_power(np.eye(A.shape[0]) + A / 16, 16)\n\ndef adjointM(T):\n    R = T[0:3, 0:3]\n    p = T[0:3, 3]\n    return np.block([[R, np.zeros((3, 3))], [bracket3(p) @ R, R]])\n\ndef r2axisangle(R):\n    if np.linalg.norm(R - np.eye(3)) < 1e-3:\n        return np.array([0, 0, 0])\n    else:\n        trace = np.clip((np.trace(R) - 1) / 2, -1, 1)  # Clip trace to the valid range\n        if trace < -1:\n            trace = -1\n        elif trace > 1:\n            trace = 1\n        theta = np.arccos(0.5*trace)\n        omega_hat = 1 / (2 * np.sin(theta)) * (R - R.T)\n        omega = np.array([omega_hat[2, 1], omega_hat[0, 2], omega_hat[1, 0]])\n        return omega * theta\n\ndef bracket_s(s):\n    return np.array([[0, -s[2], s[1], s[3]], [s[2], 0, -s[0], s[4]], [-s[1], s[0], 0, s[5]], [0, 0, 0, 0]])\n\ndef fk(M, S, theta):\n    T = np.eye(4)\n    theta = np.atleast_1d(theta)\n    for i in range(len(theta)):\n        T = np.dot(T, expm(bracket_s(S[:, i]) * theta[i]))\n    return np.dot(T, M)\n\ndef JacS(S, theta):\n    T = np.eye(4)\n    Js = np.zeros((6, len(theta)))\n    for i in range(len(theta)):\n        Si = S[:, i]\n        Js[:, i] = np.dot(adjointM(T), Si)\n        T = np.dot(T, expm(bracket_s(Si) * theta[i]))\n    return Js\n\ndef rotz(angle):\n    c, s = np.cos(angle), np.sin(angle)\n    return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n# Initialize plot\nfig, ax = plt.subplots()\nax.set_xlim(-6, 6)\nax.set_ylim(-6, 6)\nax.grid(True)\nline, = ax.plot([], [], 'o-', color=[1, 0.5, 0], linewidth=4)\nplt.ion()\n\n# Initialize parameters\nL = 1\ntheta = np.array([np.pi/8] * 5)\n\nS1 = np.array([0, 0, 1, 0, 0, 0])\nS2 = np.array([0, 0, 1, 0, -1 * L, 0])\nS3 = np.array([0, 0, 1, 0, -2 * L, 0])\nS4 = np.array([0, 0, 1, 0, -3 * L, 0])\nS5 = np.array([0, 0, 1, 0, -4 * L, 0])\n\n# Create S_eq by concatenating the individual S vectors horizontally\nS = np.column_stack((S1, S2, S3, S4, S5))\n\nM = np.vstack([np.hstack([np.eye(3), np.array([[5*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM1 = np.vstack([np.hstack([np.eye(3), np.array([[1*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM2 = np.vstack([np.hstack([np.eye(3), np.array([[2*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM3 = np.vstack([np.hstack([np.eye(3), np.array([[3*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM4 = np.vstack([np.hstack([np.eye(3), np.array([[4*L, 0, 0]]).T]), [0, 0, 0, 1]])\n\n# Desired transformation\nT_d = np.vstack([np.hstack([rotz(0), np.array([[3, -1, 0]]).T]), [0, 0, 0, 1]])\nXd = np.concatenate([r2axisangle(T_d[0:3, 0:3]), T_d[0:3, 3]])\n\n# Initial forward kinematics\nT = fk(M, S, theta)\nX = np.concatenate([r2axisangle(T[0:3, 0:3]), T[0:3, 3]])\n\n# Animation function\ndef update(frame):\n    global theta, T, X\n    if np.linalg.norm(Xd - X) > 1e-1:\n        # Calculate joint transformations\n        T1 = fk(M1, S[:, 0:1], theta[0])\n        T2 = fk(M2, S[:, 0:2], [theta[0], theta[1]])\n        T3 = fk(M3, S[:, 0:3], [theta[0], theta[1], theta[2]])\n        T4 = fk(M4, S[:, 0:4], [theta[0], theta[1], theta[2], theta[3]])\n        P_v = np.array([[0, 0]] + [T1[0:2, 3]]+ [T2[0:2, 3]]+ [T3[0:2, 3]]+ [T4[0:2, 3]] + [T[0:2, 3]]).T\n        \n        # Draw the robot\n        line.set_data(P_v[0, :], P_v[1, :])\n        \n        # Update Jacobians and compute delta_theta\n        JS = JacS(S, theta)\n        Jb = np.dot(adjointM(np.linalg.inv(T)), JS)\n        J_geometric = np.block([[T[0:3, 0:3], np.zeros((3, 3))], [np.zeros((3, 3)), T[0:3, 0:3]]]) @ Jb\n        V = Xd - X\n        delta_theta = np.dot(np.linalg.pinv(J_geometric), V)\n        \n        # Update theta\n        theta += 0.1 * delta_theta\n        print(theta)\n        T = fk(M, S, theta)\n        X = np.concatenate([r2axisangle(T[0:3, 0:3]), T[0:3, 3]])\n\n    return line,\n\n# Create and save the animation\nani = animation.FuncAnimation(fig, update, frames=np.arange(100), interval=200, blit=False)\n\n# Save the animation\nwriter = PillowWriter(fps=7)  \nani.save(\"Inverse_Kinematics_3.gif\", writer=writer)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[-0.05314555  0.56290261  0.78072182  0.56314343 -0.06077186]\n[-0.33026032  0.63092663  1.01551888  0.63990985 -0.33531103]\n[-0.55313051  0.66623181  1.19775149  0.69005746 -0.55022883]\n[-0.74036733  0.68131901  1.34397836  0.72586206 -0.72416418]\n[-0.899747    0.68214433  1.46120003  0.75317194 -0.86472893]\n[-1.03582782  0.67258771  1.55378335  0.77545496 -0.97669791]\n[-1.1519017   0.65561888  1.62525653  0.79481972 -1.06406388]\n[-1.25062936  0.63367531  1.6788238   0.81244052 -1.13056494]\n[-1.33428373  0.60877274  1.71746794  0.82885285 -1.1797263 ]\n[-1.40486005  0.58256283  1.74395497  0.84415241 -1.21486659]\n[-1.46406795  0.55687648  1.76118173  0.85743896 -1.24027725]\n[-1.51353785  0.53217219  1.77100399  0.86915723 -1.25745585]\n[-1.55474869  0.50873305  1.77503385  0.87962813 -1.26781729]\n[-1.58900369  0.4867206   1.77463151  0.8890719  -1.27265526]\n[-1.61742724  0.46621157  1.77091752  0.8976355  -1.27311668]\n[-1.6409756   0.44722316  1.76479726  0.90541746 -1.2701912 ]\n[-1.66045459  0.42973107  1.75699074  0.91248714 -1.26471358]\n[-1.67653945  0.4136828   1.74806283  0.9188978  -1.25737455]\n[-1.68979423  0.39900764  1.73845126  0.92469464 -1.24873636]\n[-1.7006894   0.38562402  1.72849118  0.9299192  -1.23925005]\n[-1.70961713  0.37344497  1.71843577  0.93461151 -1.22927246]\n[-1.71690439  0.36238196  1.70847343  0.93881083 -1.21908203]\n[-1.72282384  0.35234764  1.69874154  0.9425557  -1.20889267]\n[-1.72760309  0.34325763  1.68933768  0.94588371 -1.19886582]\n[-1.73143222  0.3350316   1.68032849  0.94883113 -1.18912055]\n[-1.73447014  0.327594    1.67175674  0.95143261 -1.17974204]\n[-1.73684978  0.32087437  1.6636469   0.95372086 -1.17078857]\n[-1.73868244  0.31480739  1.65600958  0.95572658 -1.16229719]\n[-1.74006138  0.30933284  1.64884495  0.95747827 -1.15428843]\n[-1.74106475  0.3043954   1.64214551  0.95900226 -1.14677005]\n[-1.74175811  0.29994445  1.6358982   0.96032272 -1.13974006]\n[-1.74219649  0.29593375  1.63008604  0.96146173 -1.13318921]\n[-1.74242602  0.29232115  1.62468945  0.9624394  -1.12710291]\n[-1.74248544  0.28906833  1.61968724  0.96327395 -1.12146281]\n[-1.74240725  0.28614046  1.61505735  0.96398183 -1.11624799]\n[-1.74221868  0.28350593  1.61077745  0.96457789 -1.11143595]\n[-1.74194258  0.2811361   1.60682536  0.96507547 -1.10700338]\n[-1.74159806  0.279005    1.60317935  0.96548656 -1.10292668]\n[-1.74120108  0.27708916  1.59981843  0.96582187 -1.09918245]\n```\n:::\n:::\n\n\n<details>\n\n```matlab\n\nclose all\nclear\nclc\n\n% create figure\nfigure\naxis([-6, 6, -6, 6])\ngrid on\nhold on\n\n% save as a video file\nv = VideoWriter('Inverse_Kinematics_3.mp4', 'MPEG-4');\nv.FrameRate = 25;\nopen(v);\n\n% initial joint values\nL = 1;\ntheta = [pi/8; pi/8; pi/8; pi/8; pi/8];\n\nS1 = [0 0 1 0 0 0]';\nS2 = [0 0 1 0 -1*L 0]';\nS3 = [0 0 1 0 -2*L 0]';\nS4 = [0 0 1 0 -3*L 0]';\nS5 = [0 0 1 0 -4*L 0]';\n\nS_eq = [S1, S2, S3, S4, S5];   \nM = [eye(3), [5*L;0;0]; 0 0 0 1];\nM1 = [eye(3), [1*L;0;0]; 0 0 0 1];\nM2 = [eye(3), [2*L;0;0]; 0 0 0 1];\nM3 = [eye(3), [3*L;0;0]; 0 0 0 1];\nM4 = [eye(3), [4*L;0;0]; 0 0 0 1];\n\n% Given desired Transformation matrices T_d\nT_d = [rotz(0), [3;-1;0]; 0 0 0 1];\nXd = [r2axisangle(T_d(1:3, 1:3)); T_d(1:3,4)];\n\n% T with initial joint positions\nT = fk(M, S_eq, theta);\nX = [r2axisangle(T(1:3, 1:3)); T(1:3,4)];\n\nwhile norm(Xd - X) > 1e-2\n\n    p0 = [0; 0]; % plot the robot\n    T1 = fk(M1, S1, theta(1)); % 1. get the position of each link\n    T2 = fk(M2, [S1, S2], [theta(1), theta(2)]);\n    T3 = fk(M3, [S1, S2, S3], [theta(1), theta(2), theta(3)]);\n    T4 = fk(M4, [S1, S2, S3, S4], [theta(1), theta(2), theta(3), theta(4)]);\n    P_v = [p0, T1(1:2, 4), T2(1:2, 4), T3(1:2, 4), T4(1:2, 4), T(1:2, 4)];\n\n    cla; % 2. draw the robot and save the frame\n    plot(P_v(1,:), P_v(2,:), 'o-', 'color',[1, 0.5, 0],'linewidth',4)\n    drawnow\n    frame = getframe(gcf);\n    writeVideo(v, frame); % My Implementation for inverse kinematics calculation below\n\n    JS = JacS(S_eq, theta); % Updated Space Jacobian\n    Jb = adjointM(inv(T))*JS; %Updated Body Jacobian\n    J = [T(1:3, 1:3) zeros(3); zeros(3) T(1:3, 1:3)] * Jb; % Updated Geometric Jacobian\n    V = Xd - X;\n\n    delta_theta = pinv(J)*V +(eye(5) - pinv(J)*J)*[0;0;0;0;0];\n\n    theta = double(theta + 0.1 * delta_theta); % Updating theta until the while loop is satisfied to get the desired joint positions\n    T = fk(M, S_eq, theta);\n    X = [r2axisangle(T(1:3, 1:3)); T(1:3,4)];\nend\n\nclose(v);\nclose all\n```\n</details>\n\n**Result:**\n\n<img src=\"Inverse_Kinematics_3.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\n\n## Jacobian Pseudoinverse and Redundancy\n\nThis problem continues exploring the redundant snake robot used simulated above. So far we have left ùëè = 0 in our Jacobian pseudoinverse. More generally, choosing ùëè allows us to set a secondary objective for the inverse kinematics of redundant robots.\n\nHere we establish that numerical inverse kinematics finds a solution for ùúÉ such that ùëáùë†ùëè (ùúÉ) equals the desired end-effector pose. But when working with redundant robots, multiple solutions are often possible. Choosing ùëè affects which of these solutions the algorithm selects.\n\nNow I set ùëè as the following vector (and update ùëè as ùúÉ1 changes):\n\nb = [[-theta(0) \n        0 \n        0 \n        0 \n        0]], (6x1) vector\n\n* Equation: del_theta = pinv(J)*V + (I - pinv(J)*J)*b\n\n**Here we change the delta_theta by manipulating the pseudoinverse and introducing the null-space**\n\nNote: b was a zero vector till now for all the three cases, but now we will notice the change for Case 3:\n\n**CASE 3: Modified delta_theta for Redundancy**\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom matplotlib.animation import PillowWriter\n\n# Define the necessary functions\ndef bracket3(S):\n    return np.array([[0, -S[2], S[1]], [S[2], 0, -S[0]], [-S[1], S[0], 0]])\n\ndef expm(A):\n    return np.linalg.matrix_power(np.eye(A.shape[0]) + A / 16, 16)\n\ndef adjointM(T):\n    R = T[0:3, 0:3]\n    p = T[0:3, 3]\n    return np.block([[R, np.zeros((3, 3))], [bracket3(p) @ R, R]])\n\ndef r2axisangle(R):\n    if np.linalg.norm(R - np.eye(3)) < 1e-3:\n        return np.array([0, 0, 0])\n    else:\n        trace = np.clip((np.trace(R) - 1) / 2, -1, 1)  # Clip trace to the valid range\n        if trace < -1:\n            trace = -1\n        elif trace > 1:\n            trace = 1\n        theta = np.arccos(0.5*trace)\n        omega_hat = 1 / (2 * np.sin(theta)) * (R - R.T)\n        omega = np.array([omega_hat[2, 1], omega_hat[0, 2], omega_hat[1, 0]])\n        return omega * theta\n\ndef bracket_s(s):\n    return np.array([[0, -s[2], s[1], s[3]], [s[2], 0, -s[0], s[4]], [-s[1], s[0], 0, s[5]], [0, 0, 0, 0]])\n\ndef fk(M, S, theta):\n    T = np.eye(4)\n    theta = np.atleast_1d(theta)\n    for i in range(len(theta)):\n        T = np.dot(T, expm(bracket_s(S[:, i]) * theta[i]))\n    return np.dot(T, M)\n\ndef JacS(S, theta):\n    T = np.eye(4)\n    Js = np.zeros((6, len(theta)))\n    for i in range(len(theta)):\n        Si = S[:, i]\n        Js[:, i] = np.dot(adjointM(T), Si)\n        T = np.dot(T, expm(bracket_s(Si) * theta[i]))\n    return Js\n\ndef rotz(angle):\n    c, s = np.cos(angle), np.sin(angle)\n    return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n# Initialize plot\nfig, ax = plt.subplots()\nax.set_xlim(-6, 6)\nax.set_ylim(-6, 6)\nax.grid(True)\nline, = ax.plot([], [], 'o-', color=[1, 0.5, 0], linewidth=4)\nplt.ion()\n\n# Initialize parameters\nL = 1\ntheta = np.array([np.pi/8] * 5)\n\nS1 = np.array([0, 0, 1, 0, 0, 0])\nS2 = np.array([0, 0, 1, 0, -1 * L, 0])\nS3 = np.array([0, 0, 1, 0, -2 * L, 0])\nS4 = np.array([0, 0, 1, 0, -3 * L, 0])\nS5 = np.array([0, 0, 1, 0, -4 * L, 0])\n\n# Create S_eq by concatenating the individual S vectors horizontally\nS = np.column_stack((S1, S2, S3, S4, S5))\n\nM = np.vstack([np.hstack([np.eye(3), np.array([[5*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM1 = np.vstack([np.hstack([np.eye(3), np.array([[1*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM2 = np.vstack([np.hstack([np.eye(3), np.array([[2*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM3 = np.vstack([np.hstack([np.eye(3), np.array([[3*L, 0, 0]]).T]), [0, 0, 0, 1]])\nM4 = np.vstack([np.hstack([np.eye(3), np.array([[4*L, 0, 0]]).T]), [0, 0, 0, 1]])\n\n# Desired transformation\nT_d = np.vstack([np.hstack([rotz(0), np.array([[3, -1, 0]]).T]), [0, 0, 0, 1]])\nXd = np.concatenate([r2axisangle(T_d[0:3, 0:3]), T_d[0:3, 3]])\n\n# Initial forward kinematics\nT = fk(M, S, theta)\nX = np.concatenate([r2axisangle(T[0:3, 0:3]), T[0:3, 3]])\n\n# Animation function\ndef update(frame):\n    global theta, T, X\n    if np.linalg.norm(Xd - X) > 1e-1:\n        # Calculate joint transformations\n        T1 = fk(M1, S[:, 0:1], theta[0])\n        T2 = fk(M2, S[:, 0:2], [theta[0], theta[1]])\n        T3 = fk(M3, S[:, 0:3], [theta[0], theta[1], theta[2]])\n        T4 = fk(M4, S[:, 0:4], [theta[0], theta[1], theta[2], theta[3]])\n        P_v = np.array([[0, 0]] + [T1[0:2, 3]]+ [T2[0:2, 3]]+ [T3[0:2, 3]]+ [T4[0:2, 3]] + [T[0:2, 3]]).T\n        \n        # Draw the robot\n        line.set_data(P_v[0, :], P_v[1, :])\n        \n        # Update Jacobians and compute delta_theta\n        JS = JacS(S, theta)\n        Jb = np.dot(adjointM(np.linalg.inv(T)), JS)\n        J_geometric = np.block([[T[0:3, 0:3], np.zeros((3, 3))], [np.zeros((3, 3)), T[0:3, 0:3]]]) @ Jb\n        V = Xd - X\n\n        # [del_theta = pinv(J)*V + (I - pinv(J)*J)*b] <- Updated delta_theta to include the null-space with the specified b vector\n        delta_theta = np.dot(np.linalg.pinv(J_geometric), V) + np.dot((np.eye(5) - np.dot(np.linalg.pinv(J_geometric), J_geometric)), np.array([-theta[0], 0, 0, 0, 0]))\n        \n        # Update theta\n        theta += 0.1 * delta_theta\n        print(theta)\n        T = fk(M, S, theta)\n        X = np.concatenate([r2axisangle(T[0:3, 0:3]), T[0:3, 3]])\n\n    return line,\n\n# Create and save the animation\nani = animation.FuncAnimation(fig, update, frames=np.arange(100), interval=200, blit=False)\n\n# Save the animation\nwriter = PillowWriter(fps=7)  \nani.save(\"Inverse_Kinematics_Null.gif\", writer=writer)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[-0.05825544  0.57353743  0.77725608  0.55724953 -0.05693715]\n[-0.33556013  0.64086137  1.01264325  0.63447309 -0.33163482]\n[-0.55265956  0.6656847   1.19866303  0.68949924 -0.55051267]\n[-0.72772164  0.6618604   1.35115636  0.73355974 -0.73223516]\n[-0.86867406  0.63683335  1.47639744  0.77174108 -0.88425018]\n[-0.98076153  0.59594891  1.57808655  0.80704634 -1.01096916]\n[-1.06833973  0.54347282  1.65917606  0.8414017  -1.11585497]\n[-1.1353063   0.48290628  1.72238131  0.87600273 -1.20200833]\n[-1.18514846  0.41710933  1.77026723  0.91149258 -1.27228264]\n[-1.2209048   0.34840453  1.80524701  0.9480471  -1.32935905]\n[-1.24502034  0.27912295  1.8300012   0.98468336 -1.37700902]\n[-1.25970342  0.21019292  1.84615904  1.02171894 -1.41627532]\n[-1.26680285  0.14229845  1.85516799  1.05926318 -1.44822922]\n[-1.26782221  0.07593138  1.85828783  1.09726722 -1.47392191]\n[-1.2639633   0.01142763  1.85659734  1.13558306 -1.49433971]\n[-1.25618019 -0.05100306  1.85100817  1.17401545 -1.510373  ]\n[-1.24523121 -0.11125002  1.84228215  1.21235971 -1.52280077]\n[-1.23172299 -0.16927717  1.83104994  1.25042495 -1.53228789]\n[-1.2161452  -0.22510185  1.81782933  1.2880459  -1.53939092]\n[-1.19889701 -0.27877757  1.80304255  1.32508688 -1.54456879]\n[-1.18030676 -0.3303806   1.7870319   1.36144127 -1.54819533]\n[-1.16064685 -0.38000008  1.77007342  1.39702856 -1.55057206]\n[-1.14014478 -0.42773089  1.75238878  1.4317905  -1.55193998]\n[-1.1189917  -0.47366884  1.73415522  1.46568709 -1.55249019]\n[-1.09734903 -0.51790738  1.71551396  1.49869293 -1.55237297]\n[-1.07535365 -0.56053566  1.69657713  1.530794   -1.55170554]\n[-1.0531221  -0.60163728  1.6774335   1.56198494 -1.55057842]\n[-1.0307539  -0.64128977  1.65815321  1.59226689 -1.54906086]\n[-1.00833432 -0.67956441  1.63879161  1.62164574 -1.54720524]\n[-0.98593665 -0.71652631  1.61939242  1.65013075 -1.54505065]\n[-0.96362401 -0.75223473  1.59999035  1.67773349 -1.54262592]\n[-0.9414509  -0.78674343  1.58061313  1.7044671  -1.53995205]\n[-0.91946448 -0.8201012   1.56128328  1.73034568 -1.53704415]\n[-0.89770558 -0.8523523   1.54201945  1.75538388 -1.5339131 ]\n[-0.87620958 -0.88353702  1.52283751  1.7795967  -1.53056685]\n[-0.8550071  -0.91369218  1.50375142  1.80299926 -1.52701146]\n[-0.83412458 -0.94285159  1.48477389  1.82560676 -1.52325189]\n[-0.81358477 -0.97104661  1.46591687  1.84743444 -1.5192927 ]\n[-0.79340707 -0.9983065   1.44719191  1.8684976  -1.51513849]\n[-0.77360792 -1.02465885  1.42861042  1.88881166 -1.51079429]\n[-0.75420097 -1.05012997  1.41018377  1.90839219 -1.50626577]\n[-0.73519738 -1.07474516  1.39192337  1.927255   -1.50155939]\n```\n:::\n:::\n\n\n**MATLAB implementation**\n\n<details>\n\n```matlab\n\nclose all\nclear\nclc\n\n% create figure\nfigure\naxis([-6, 6, -6, 6])\ngrid on\nhold on\n\n% save as a video file\nv = VideoWriter('Inverse_Kinematics_3_null_space.mp4', 'MPEG-4');\nv.FrameRate = 25;\nopen(v);\n\n% initial joint values\nL = 1;\ntheta = [pi/8; pi/8; pi/8; pi/8; pi/8];\n\nS1 = [0 0 1 0 0 0]';\nS2 = [0 0 1 0 -1*L 0]';\nS3 = [0 0 1 0 -2*L 0]';\nS4 = [0 0 1 0 -3*L 0]';\nS5 = [0 0 1 0 -4*L 0]';\n\nS_eq = [S1, S2, S3, S4, S5];   \nM = [eye(3), [5*L;0;0]; 0 0 0 1];\nM1 = [eye(3), [1*L;0;0]; 0 0 0 1];\nM2 = [eye(3), [2*L;0;0]; 0 0 0 1];\nM3 = [eye(3), [3*L;0;0]; 0 0 0 1];\nM4 = [eye(3), [4*L;0;0]; 0 0 0 1];\n\n% Given desired Transformation matrices T_d\nT_d = [rotz(0), [3;-1;0]; 0 0 0 1];\nXd = [r2axisangle(T_d(1:3, 1:3)); T_d(1:3,4)];\n\n% T with initial joint positions\nT = fk(M, S_eq, theta);\nX = [r2axisangle(T(1:3, 1:3)); T(1:3,4)];\n\nwhile norm(Xd - X) > 1e-2\n\n    p0 = [0; 0]; % plot the robot\n    T1 = fk(M1, S1, theta(1)); % 1. get the position of each link\n    T2 = fk(M2, [S1, S2], [theta(1), theta(2)]);\n    T3 = fk(M3, [S1, S2, S3], [theta(1), theta(2), theta(3)]);\n    T4 = fk(M4, [S1, S2, S3, S4], [theta(1), theta(2), theta(3), theta(4)]);\n    P_v = [p0, T1(1:2, 4), T2(1:2, 4), T3(1:2, 4), T4(1:2, 4), T(1:2, 4)];\n\n    cla; % 2. draw the robot and save the frame\n    plot(P_v(1,:), P_v(2,:), 'o-', 'color',[1, 0.5, 0],'linewidth',4)\n    drawnow\n    frame = getframe(gcf);\n    writeVideo(v, frame); % My Implementation for inverse kinematics calculation below\n\n    JS = JacS(S_eq, theta); % Updated Space Jacobian\n    Jb = adjointM(inv(T))*JS; %Updated Body Jacobian\n    J = [T(1:3, 1:3) zeros(3); zeros(3) T(1:3, 1:3)] * Jb; % Updated Geometric Jacobian\n    V = Xd - X;\n\n    delta_theta = pinv(J)*V +(eye(5) - pinv(J)*J)*[-theta(1);0;0;0;0];\n\n    theta = double(theta + 0.1 * delta_theta); % Updating theta until the while loop is satisfied to get the desired joint positions\n    T = fk(M, S_eq, theta);\n    X = [r2axisangle(T(1:3, 1:3)); T(1:3,4)];\nend\n\nclose(v);\nclose all\n```\n\n</details>\n\n**Result:**\n\n<img src=\"Inverse_Kinematics_Null.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\n\nThe final joint positions (approximately):\n\n* **Case 3 with ùëè = 0:**\nùúÉ = [‚àí1.51 0.29 1.36 0.78 ‚àí0.92]^ùëá\n\n* **Case 3 with ùëè = ‚àíùúÉ1:**\nùúÉ = [‚àí0.38 ‚àí1.40 1.20 1.70 ‚àí1.12]^ùëá\n\nComparing these two results, we have that |ùúÉ1| is smaller (and ùúÉ1 is closer to zero) with the secondary objective:\n\n* **0.38 < 1.51**\n\nThere are several reasons why we may want to minimize a joint angle:\n\n    ‚Ä¢ The actuator at that joint moves more slowly than the other actuators.\n\n    ‚Ä¢ Moving the actuator at that joint consumes more power as compared to the other actuators along the robot arm.\n\n    ‚Ä¢ We want to avoid colliding with an obstacle, and we need to keep one or more joints at a specific angle to avoid that obstacle\n\n\n\n\n\n## Potential Fields in Motion Planning\n\nHere I will use potential fields to get a motion plan for the 2-DoF environment shown below. Here the drone‚Äôs position is ùúÉ = [ùë•, ùë¶]^ùëá.\n\nImplementing the potential fields approach:\n\n‚Ä¢ Setting ùúÉùë†ùë°ùëéùëüùë° = [0, 0]^ùëá and ùúÉùëîùëúùëéùëô = [1, 1]^ùëá\n\n‚Ä¢ The first obstacle has center ùëê1 = [0.3, 0.5]^ùëá and radius ùëü1 = 0.125\n\n‚Ä¢ The second obstacle has center ùëê2 = [0.7, 0.5]^ùëá and radius ùëü2 = 0.225\n\nNOTE: Always start with a low learning rate ùõº in your g\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation, PillowWriter\n\n# Parameters\ntheta_start = np.array([0.0, 0.0])\ntheta_goal = np.array([1.0, 1.0])\ncenters = np.array([[0.3, 0.5], [0.7, 0.5]])\nradii = np.array([0.125, 0.225])\n\n# Function to compute potential field\ndef field(theta, theta_goal, centers, radii):\n    U = 0.5 * np.linalg.norm(theta_goal - theta)**2\n    for idx in range(len(radii)):\n        center = centers[idx]\n        radius = radii[idx]\n        dist = np.linalg.norm(center - theta)\n        if dist < radius:\n            U += 0.5 * (1/dist - 1/radius)**2\n    return U\n\n# Initialize figure\nfig, ax = plt.subplots()\nax.grid(True)\n\n# Drawing circles\nfor idx in range(len(radii)):\n    circle = plt.Circle(centers[idx], radii[idx], color=[0.5, 0.5, 0.5], fill=False)\n    ax.add_patch(circle)\n\n# Start and goal points\nax.plot(theta_start[0], theta_start[1], 'ko', markerfacecolor='k')\nax.plot(theta_goal[0], theta_goal[1], 'ko', markerfacecolor='k')\nax.axis('equal')\n\n# Parameters for gradient descent\ntheta = theta_start\ndelta = 0.01  # Adjusted delta value\nlearning_rate = 0.01  # Adjusted learning rate\npath = [theta_start]  # To store the path\n\n# Animation update function\ndef update(frame):\n    global theta\n    if np.linalg.norm(theta - theta_goal) < 0.1:\n        return\n\n    U = field(theta, theta_goal, centers, radii)\n    U1 = field(theta + np.array([delta, 0.0]), theta_goal, centers, radii)\n    U2 = field(theta + np.array([0.0, delta]), theta_goal, centers, radii)\n    Ugrad = np.array([U1 - U, U2 - U]) / delta\n    theta -= learning_rate * Ugrad\n    path.append(theta.copy())\n    ax.plot([p[0] for p in path], [p[1] for p in path], 'o', color=[1, 0.5, 0], markerfacecolor=[1, 0.5, 0])\n\n# Create animation\nani = FuncAnimation(fig, update, frames=np.arange(300), repeat=False)\n\n# Save to GIF using PillowWriter\ngif_path = 'Potential_Field.gif'\nani.save(gif_path, writer=PillowWriter(fps=30))\n```\n:::\n\n\n**MATLAB implementation**\n\n<details>\n\n```matlab\n\nclear\nclose all\n% Parameters\ntheta_start = [0; 0];\ntheta_goal = [1; 1];\ncenters = [.3, .7; .5, .5];\nradii = [.125, .225];\n% Create figure\nfigure\ngrid on\nhold on\nfor idx = 1:length(radii)\n viscircles(centers(:,idx)', radii(idx), 'Color', [0.5, 0.5, 0.5]);\nend\nplot(theta_start(1), theta_start(2), 'ko', 'MarkerFaceColor', 'k')\nplot(theta_goal(1), theta_goal(2), 'ko', 'MarkerFaceColor', 'k')\naxis equal\n% Gradient descent down potential field\ntheta = theta_start;\ndelta = 0.01;\nlearning_rate = 0.01;\nfor idx = 1:1000\n if norm(theta - theta_goal) < 0.1\n break\n end\n U = field(theta, theta_goal, centers, radii);\n U1 = field(theta + [delta; 0], theta_goal, centers, radii);\n U2 = field(theta + [0; delta], theta_goal, centers, radii);\n Ugrad = [U1 - U; U2 - U] / delta;\n theta = theta - learning_rate * Ugrad;\n plot(theta(1), theta(2), 'o', 'color', [1, 0.5, 0], ...\n 'MarkerFaceColor', [1, 0.5, 0])\nend\n% Find potential field at position theta\nfunction U = field(theta, theta_goal, centers, radii)\n U = 0.5 * norm(theta_goal - theta)^2;\n for idx = 1:length(radii)\n center = centers(:, idx);\n radius = radii(idx);\n dist = norm(center - theta);\n if dist < radius\n U = U + 0.5 * (1/dist - 1/radius)^2;\n end\n end\nend\n```\n</details>\n\n**Result:**\n\n<img src=\"Potential_Field.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\n\n\n* Modifying the position of the obstacles so that a valid plan from ùúÉùë†ùë°ùëéùëüùë° to ùúÉùëîùëúùëéùëô exists but the potential fields planner fails (i.e., gets stuck). Below is the simulation that shows the obstacles and the failed motion plan.\n\nThere are many possible solutions. For instance, I am setting ùëê1 = [0.4, 0.5]^ùëá.\n\n**Motion Plan Failure**\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation, PillowWriter\n\n# Parameters\ntheta_start = np.array([0.0, 0.0])\ntheta_goal = np.array([1.0, 1.0])\ncenters = np.array([[0.4, 0.5], [0.5, 0.5]])\nradii = np.array([0.125, 0.225])\n\n# Function to compute potential field\ndef field(theta, theta_goal, centers, radii):\n    U = 0.5 * np.linalg.norm(theta_goal - theta)**2\n    for idx in range(len(radii)):\n        center = centers[idx]\n        radius = radii[idx]\n        dist = np.linalg.norm(center - theta)\n        if dist < radius:\n            U += 0.5 * (1/dist - 1/radius)**2\n    return U\n\n# Initialize figure\nfig, ax = plt.subplots()\nax.grid(True)\n\n# Drawing circles\nfor idx in range(len(radii)):\n    circle = plt.Circle(centers[idx], radii[idx], color=[0.5, 0.5, 0.5], fill=False)\n    ax.add_patch(circle)\n\n# Start and goal points\nax.plot(theta_start[0], theta_start[1], 'ko', markerfacecolor='k')\nax.plot(theta_goal[0], theta_goal[1], 'ko', markerfacecolor='k')\nax.axis('equal')\n\n# Parameters for gradient descent\ntheta = theta_start\ndelta = 0.01  # Adjusted delta value\nlearning_rate = 0.01  # Adjusted learning rate\npath = [theta_start]  # To store the path\n\n# Animation update function\ndef update(frame):\n    global theta\n    if np.linalg.norm(theta - theta_goal) < 0.1:\n        return\n\n    U = field(theta, theta_goal, centers, radii)\n    U1 = field(theta + np.array([delta, 0.0]), theta_goal, centers, radii)\n    U2 = field(theta + np.array([0.0, delta]), theta_goal, centers, radii)\n    Ugrad = np.array([U1 - U, U2 - U]) / delta\n    theta -= learning_rate * Ugrad\n    path.append(theta.copy())\n    ax.plot([p[0] for p in path], [p[1] for p in path], 'o', color=[1, 0.5, 0], markerfacecolor=[1, 0.5, 0])\n\n# Create animation\nani = FuncAnimation(fig, update, frames=np.arange(300), repeat=False)\n\n# Save to GIF using PillowWriter\ngif_path = 'Potential_Field_fail.gif'\nani.save(gif_path, writer=PillowWriter(fps=30))\n```\n:::\n\n\n**MATLAB Implementation**\n\n<details>\n\n```matlab\nclear\nclose all\n\n% Start and goal environments\ntheta_start= [0; 0];\ntheta_goal = [1; 1];\n\n% Modified obstacle positions and sizes\nobs_c21 = [0.3; 0.5];  % Shifted first obstacle closer to the second\nobs_r21 = 0.15;        % Slightly increased radius\nobs_c22 = [0.8; 0.5];  % Shifted second obstacle closer to the first\nobs_r22 = 0.25;        % Slightly increased radius\n\n% Visualize the environment\nfigure\ngrid on\nhold on\naxis([0, 1, 0, 1])\naxis equal\nviscircles(obs_c21', obs_r21, 'Color', [0.5, 0.5, 0.5]);\nviscircles(obs_c22', obs_r22, 'Color', [0.5, 0.5, 0.5]);\nplot(0, 0, 'ko', 'MarkerFaceColor', 'k');\nplot(1, 1, 'ko', 'MarkerFaceColor', 'k');\n\n% Setting the variables\nalpha= 0.01;\nepsilon = 0.1;\ndelta= 0.01;\n\n% Initial trajectory\ntheta(:,1) = theta_start;\nt=1;\ndel_Unet=1;\n\nwhile norm(del_Unet)> epsilon\n    del_Ux= U_theta(theta(:,t) + [delta;0]);\n    del_Uy= U_theta(theta(:,t)+ [0;delta]);\n    del_U= U_theta(theta(:,t));\n\n    del_Unet=[del_Ux-del_U; del_Uy-del_U]/delta;\n\n    theta(:,t+1)= theta(:,t)- alpha*del_Unet;\n    t=t+1;\nend\n\n\ngrid on\nhold on\naxis equal\nplot(theta(1,:), theta(2,:), 'o-',...\n    'Color', [1, 0.5, 0], 'LineWidth', 2);\n    \n\nfunction U = U_theta(theta) \n    beta=2;\n    gamma=1;\n    theta_goal = [1; 1];\n    % Modified obstacle positions and sizes\n    obs_c21 = [0.3; 0.5];  % Update obstacle parameters\n    obs_r21 = 0.15;\n    obs_c22 = [0.6; 0.5];\n    obs_r22 = 0.25;\n\n    Urep1=0;\n    Urep2=0;\n\n    Uatt=0.5*beta*norm(theta_goal-theta)^2;    \n\n    if norm(obs_c21-theta)<= obs_r21\n        Urep1=0.5* gamma*((1/norm(obs_c21-theta))- (1/obs_r21))^2;\n    end\n    if norm(obs_c22-theta)<= obs_r22\n        Urep2= 0.5*gamma*((1/norm(obs_c22-theta))- (1/obs_r22))^2;\n    end\n\n    Urep= Urep1+ Urep2;\n    disp(Urep);\n    U= Uatt + Urep;\nend\n```\n\n</details>\n\n**Result:**\n\n<img src=\"Potential_Field_fail.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\nThis failure occurs because the robot uses gradient descent to move towards decreasing potential energy, and the robot gets trapped in a **local minimum**.\n\nIn this modification, the obstacles are placed closer to each other, potentially creating a narrow corridor that the drone might not be able to navigate due to the combined repulsive forces. This setup can result in the planner getting stuck in a local minimum, where the drone is unable to progress towards the goal. Thus, we place a local minimim in between the start and goal. **Gradient descent** can only climb \"down\" so if it's surrounded by high gradients, it can't escape.\n\n\n\n\n## Trajectory Optimization\n\n**MATLAB Implementations**\n\nHere we are using trajectory optimization to perform motion planning in 2-DoF environments. As before, the mobile robot‚Äôs position is ùúÉ = [ùë•, ùë¶]^ùëá.\n\nImplementing the trajectory optimization algorithm Below. My code should be able to work with an arbitrary number of waypoints and circular obstacles. \n\nThus setting the initial trajectory ùúâ^0 as:\n\n* xi_0 = [linspace(theta_start(1), theta_goal(1), k);\nlinspace(theta_start(2), theta_goal(2), k)];\n\n\n* **Environment 1: One obstacle with center ùëê1 = [0.2, 0.35]^ùëá and radius ùëü1 = 0.2. A second obstacle with center ùëê2 = [0.5, 0.3]^ùëá and radius ùëü2 = 0.2. A third obstacle with center ùëê3 = [0.7, 0.5]^ùëá and radius ùëü3 = 0.2. Setting ùëò = 20.**\n\n**MATLAB Code**\n\n<details>\n\n```matlab\n\nclear\nclose all\n\n% start and goal\ntheta_start = [0;0];\ntheta_goal = [1;1];\ncenters = [0.2 0.5, 0.7; 0.35 0.3, 0.5];\nradii = [0.2, 0.2, 0.2];\n\n% initial trajectory\nn = 2;\nk = 20;\nxi_0 = [linspace(theta_start(1), theta_goal(1), k);...\n linspace(theta_start(2), theta_goal(2), k)];\nxi_0_vec = reshape(xi_0, [], 1);\n\n% start and goal equality constraints\nA = [eye(n) zeros(n, n*(k-1));...\n zeros(n, n*(k-1)), eye(n)];\nB = [theta_start; theta_goal];\n\n% nonlinear optimization\noptions = optimoptions('fmincon','Display','final',...\n 'Algorithm','sqp','MaxFunctionEvaluations',1e5);\nxi_star_vec = fmincon(@(xi) cost(xi, centers, radii), xi_0_vec, ...\n [], [], A, B, [], [], [], options);\nxi_star = reshape(xi_star_vec, 2, []);\n\n% plot result\nfigure\ngrid on\nhold on\naxis equal\nfor idx = 1:length(radii)\n viscircles(centers(:, idx)', radii(idx), 'Color', [0.5, 0.5, ...\n 0.5]);\nend\nplot(xi_0(1,:), xi_0(2,:), 'o-', 'Color', [0.3, 0.3, ...\n 0.3], 'LineWidth', 3);\nplot(xi_star(1,:), xi_star(2,:), 'o-', 'Color', [1, 0.5, ...\n 0], 'LineWidth', 3);\n% cost function to minimize\n\nfunction C = cost(xi, centers, radii)\n xi = reshape(xi, 2, []);\n C = 0;\n for idx = 2:length(xi)\n theta_curr = xi(:, idx);\n theta_prev = xi(:, idx - 1);\n C = C + norm(theta_curr - theta_prev)^2;\n for jdx = 1:length(radii)\n center = centers(:, jdx);\n radius = radii(jdx);\n if norm(theta_curr - center) < radius\n C = C + 0.5*(1/norm(theta_curr - center) - 1/radius)^2;\n end\n end\n end\nend\n```\n</details>\n\n**Result**\n\n![](Images/Traj_Env_1.png){fig-align=\"left\" width=40%}\n\n\n* **Environment 2: One obstacle with center ùëê1 = [0.5, 0.3]^ùëá and radius ùëü1 = 0.3. A second obstacle with center ùëê2 = [0.5, 0.7]^ùëá and radius ùëü2 = 0.2. Setting ùëò = 15.**\n\n**MATLAB implementation**\n\n<details>\n\n```matlab\n\nclear\nclose all\n\n% start and goal\ntheta_start = [0;0];\ntheta_goal = [1;1];\ncenters = [0.5 0.5; 0.3 0.7];\nradii = [0.3, 0.2];\n\n% initial trajectory\nn = 2;\nk = 15;\nxi_0 = [linspace(theta_start(1), theta_goal(1), k);...\n linspace(theta_start(2), theta_goal(2), k)];\nxi_0_vec = reshape(xi_0, [], 1);\n\n% start and goal equality constraints\nA = [eye(n) zeros(n, n*(k-1));...\n zeros(n, n*(k-1)), eye(n)];\nB = [theta_start; theta_goal];\n\n% nonlinear optimization\noptions = optimoptions('fmincon','Display','final',...\n 'Algorithm','sqp','MaxFunctionEvaluations',1e5);\nxi_star_vec = fmincon(@(xi) cost(xi, centers, radii), xi_0_vec, ...\n [], [], A, B, [], [], [], options);\nxi_star = reshape(xi_star_vec, 2, []);\n\n% plot result\nfigure\ngrid on\nhold on\naxis equal\nfor idx = 1:length(radii)\n viscircles(centers(:, idx)', radii(idx), 'Color', [0.5, 0.5, ...\n 0.5]);\nend\nplot(xi_0(1,:), xi_0(2,:), 'o-', 'Color', [0.3, 0.3, ...\n 0.3], 'LineWidth', 3);\nplot(xi_star(1,:), xi_star(2,:), 'o-', 'Color', [1, 0.5, ...\n 0], 'LineWidth', 3);\n\n% cost function to minimize\nfunction C = cost(xi, centers, radii)\n xi = reshape(xi, 2, []);\n C = 0;\n for idx = 2:length(xi)\n theta_curr = xi(:, idx);\n theta_prev = xi(:, idx - 1);\n C = C + norm(theta_curr - theta_prev)^2;\n for jdx = 1:length(radii)\n center = centers(:, jdx);\n radius = radii(jdx);\n if norm(theta_curr - center) < radius\n C = C + 0.5*(1/norm(theta_curr - center) - 1/radius)^2;\n end\n end\n end\nend\n```\n</details>\n\n**Result**\n\n![](Images/Traj_Env_2.png){fig-align=\"left\" width=40%}\n\n\n* **Environment 3: One obstacle with center ùëê1 = [0.55, 0.5]^ùëá and radius ùëü1 = 0.3. Trajectory should have ùëò = 10 waypoints.**\n\n**MATLAB implementation**\n\n<details>\n\n```matlab\n\nclear\nclose all\n\n% start and goal\ntheta_start = [0;0];\ntheta_goal = [1;1];\ncenters = [0.55; 0.5];\nradii = 0.3;\n\n% initial trajectory\nn = 2;\nk = 10;\nxi_0 = [linspace(theta_start(1), theta_goal(1), k);...\n linspace(theta_start(2), theta_goal(2), k)];\nxi_0_vec = reshape(xi_0, [], 1);\n\n% start and goal equality constraints\nA = [eye(n) zeros(n, n*(k-1));...\n zeros(n, n*(k-1)), eye(n)];\nB = [theta_start; theta_goal];\n\n% nonlinear optimization\noptions = optimoptions('fmincon','Display','final',...\n 'Algorithm','sqp','MaxFunctionEvaluations',1e5);\nxi_star_vec = fmincon(@(xi) cost(xi, centers, radii), xi_0_vec, ...\n [], [], A, B, [], [], [], options);\nxi_star = reshape(xi_star_vec, 2, []);\n\n% plot result\nfigure\ngrid on\nhold on\naxis equal\nfor idx = 1:length(radii)\n viscircles(centers(:, idx)', radii(idx), 'Color', [0.5, 0.5, ...\n 0.5]);\nend\nplot(xi_0(1,:), xi_0(2,:), 'o-', 'Color', [0.3, 0.3, ...\n 0.3], 'LineWidth', 3);\nplot(xi_star(1,:), xi_star(2,:), 'o-', 'Color', [1, 0.5, ...\n 0], 'LineWidth', 3);\n\n% cost function to minimize\nfunction C = cost(xi, centers, radii)\n xi = reshape(xi, 2, []);\n C = 0;\n for idx = 2:length(xi)\n theta_curr = xi(:, idx);\n theta_prev = xi(:, idx - 1);\n C = C + norm(theta_curr - theta_prev)^2;\n for jdx = 1:length(radii)\n center = centers(:, jdx);\n radius = radii(jdx);\n if norm(theta_curr - center) < radius\n C = C + 0.5*(1/norm(theta_curr - center) - 1/radius)^2;\n end\n end\n end\nend\n```\n</details>\n\n**Result**\n\n![](Images/Traj_Env_3.png){fig-align=\"left\" width=40%}\n\n**Legend: Here, in all the three environments the gray line is the initial trajectory ùúâ^0, while the orange line is the optimal trajectory ùúâ.**\n\n# Special Scenario\n\n**Consider an environment with two obstacles:**\n\n* ùúÉùë†ùë°ùëéùëüùë° = [0, 0]^ùëá and ùúÉùëîùëúùëéùëô = [1, 1]^ùëá.\n\n* First obstacle with center ùëê1 = [0.4, 0.6]^ùëá and radius ùëü1 = 0.2.\n\n* Second obstacle with center ùëê2 = [0.6, 0.4]^ùëá and radius ùëü2 = 0.2.\n\n* The trajectory ùúâ should have ùëò = 20 waypoints.\n\nModifying the initial trajectory ùúâ^0 so that the optimal trajectory goes around both obstacles.\n\n**Solution:**\n\nFor this environment an **initial trajectory ùúâ^0** that moves straight from start to goal gets stuck. The nonlinear optimizer cannot find a way to modify this initial trajectory to **decrease the cost** (i.e., we are stuck in a local minima), and so the final answer simply jumps across the obstacles. We can fix this problem by choosing an initial trajectory that moves either above or below the obstacles. \n\nFor example, try:\n**ùúâ^0 =[[0 0 0 . . . 0;**\n       **0 1/(ùëò ‚àí 1) 2/(ùëò ‚àí 1) . . . 1]], ùúâ^0 ‚àà R^(ùëõ√óùëò)**\n\nThis results in an optimal trajectory ùúâ that goes above both obstacles. See the figure below. If you selected an initial trajectory that caused the robot to converge to a path below both obstacles, that is also fine.\n\n**Result**\n\n![](Images/Traj_Env_4_special.png){fig-align=\"left\" width=40%}\n\n\n\n## RRT Algorithm\n\n* **The path plan should actually work on a robot.** If the path plan makes the robot turn at sharp angles but the robot can‚Äôt move at sharp angles (like a car), that path plan shouldn‚Äôt be allowed.\n\n* **The path plan should be as close to optimal as possible.** While it‚Äôs nice to find any path plan that gets the robot from a start location to a goal location, that isn‚Äôt enough unfortunately. We‚Äôd like something that‚Äôs somewhat efficient. Not only will it help the robot complete its task as fast as possible, but it‚Äôll also conserve its precious battery life.\n\n* **The path plan should avoid colliding with walls.** This obviously goes without saying. Robots can be pretty expensive, and crashing is never a good thing. My little robot alone cost me well over a thousand bucks.\n\nOne of the most popular algorithms for coming up with a path plan that tries to satisfies these conditions is called Rapidly-exploring Random Trees (RRT). Since a picture is worth a thousand words, check out the diagram below. Let‚Äôs suppose the robot has to go from a start location (the red dot) to a goal location (the green dot) in a simple map without any obstacles. Basically, we‚Äôll start off with a tree that has a root node representing the start position of the robot. After that, we‚Äôll build the tree up gradually. How? We‚Äôll take a bunch of random samples of the map, make a new node for each random sample, and insert each new node into the tree somehow. Once the tree has a node that‚Äôs close enough to the goal position of the robot, we‚Äôre done.\n\n\nHere we are using the RRT algorithm to perform motion planning in 2-DoF environments. As before, the mobile robot‚Äôs position is ùúÉ = [ùë•, ùë¶]^ùëá.\n\nImplementing the RRT algorithm below. This code should be able to work with an arbitrary number of circular obstacles with 2 conditions:\n\n‚Ä¢ The bounds of the workspace are ùë• ‚àà [0, 1], ùë¶ ‚àà [0, 1]\n‚Ä¢ The motion plan must end within ùúñ = 0.1 units of the goal\n\n**Code Implementation** \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom matplotlib.animation import PillowWriter, FuncAnimation\n\n# Define start and goal positions\ntheta_start = {'coord': np.array([0, 0]), 'parent': None}\ntheta_goal = np.array([1, 1])\n\n# Workspace bounds\nx_bounds = [0, 1]\ny_bounds = [0, 1]\n\n# Define obstacles\nobstacles = np.array([\n    [0.5, 0.3, 0.2],\n    [0.7, 0.7, 0.2],\n    [0.6, 0.4, 0.1],\n    [0.4, 0.3, 0.2],\n    [0.1, 0.75, 0.3]\n])\n\n# RRT parameters\nepsilon = 0.1  # Goal threshold\ndelta = 0.05   # Step size\nN = 1000       # Number of iterations\n\n# Initialize tree\nG = [theta_start]\n\n# Visualize environment setup\nfig, ax = plt.subplots()\nax.grid(True)\nax.set_xlim(x_bounds)\nax.set_ylim(y_bounds)\nax.set_aspect('equal')\n\n# Plot obstacles\nfor obstacle in obstacles:\n    circle = Circle(obstacle[0:2], obstacle[2], color='gray', fill=False)\n    ax.add_patch(circle)\n\n# Plot start and goal\nstart_plot, = ax.plot(theta_start['coord'][0], theta_start['coord'][1], 'ko', markerfacecolor='k')\ngoal_plot, = ax.plot(theta_goal[0], theta_goal[1], 'ko', markerfacecolor='k')\n\n# This flag is used to stop the animation once the goal is reached\ngoal_reached = False\n\n# Animation update function\ndef update(frame):\n    global G, goal_reached\n\n    if goal_reached:\n        return\n\n    theta_rand = theta_goal if np.random.rand() < 0.2 else np.random.rand(2)\n    distances = [np.linalg.norm(node['coord'] - theta_rand) for node in G]\n    theta_near_index = np.argmin(distances)\n    theta_near = G[theta_near_index]\n    vec_to_rand = theta_rand - theta_near['coord']\n    vec_to_rand = delta * vec_to_rand / np.linalg.norm(vec_to_rand)\n    theta_new = {'coord': theta_near['coord'] + vec_to_rand, 'parent': theta_near_index}\n\n    if not is_collision(theta_new['coord'], obstacles):\n        G.append(theta_new)\n        ax.plot([theta_near['coord'][0], theta_new['coord'][0]], [theta_near['coord'][1], theta_new['coord'][1]], 'k-', linewidth=2)\n        ax.plot(theta_new['coord'][0], theta_new['coord'][1], 'o', color='gray', markerfacecolor='gray')\n\n        if np.linalg.norm(theta_new['coord'] - theta_goal) < epsilon:\n            # Draw the final path in orange\n            current = theta_new\n            while current['parent'] is not None:\n                parent = G[current['parent']]\n                ax.plot([current['coord'][0], parent['coord'][0]], [current['coord'][1], parent['coord'][1]], color='orange', linewidth=3)\n                current = parent\n            goal_reached = True\n\n# Collision checking function\ndef is_collision(coord, obstacles):\n    return any(np.linalg.norm(coord - obstacle[0:2]) < obstacle[2] for obstacle in obstacles)\n\n# Create the animation\nani = FuncAnimation(fig, update, frames=N, repeat=False)\n\n# Save the animation as a GIF\ngif_path = \"RRT_main.gif\"\nwriter = PillowWriter(fps=20)\nani.save(gif_path, writer=writer)\n\n# Close the plot\nplt.close()\n```\n:::\n\n\n**MATLAB Implementation**\n\n<details>\n\n```matlab\nclear\nclose all\n\n% Define start and goal positions\ntheta_start.coord = [0; 0];\ntheta_goal = [1; 1];\n\n% Workspace bounds\nx_bounds = [0, 1];\ny_bounds = [0, 1];\n\n% Define obstacles\n% Each row is an obstacle with format: [center_x, center_y, radius]\nobstacles = [\n    0.5, 0.3, 0.2;\n    0.7, 0.7, 0.2;\n    0.6, 0.4, 0.1;\n    0.4, 0.3, 0.2;\n    0.1, 0.75, 0.3;\n    % Add as many obstacles required, satisfying the condition of arbitrary\n    % number of obstacles' inclusion\n];\n\n% RRT parameters\nepsilon = 0.1; % Goal threshold\ndelta = 0.05;  % Step size\nN = 1000;      % Number of iterations\n\n% Visualize environment\nfigure\nhold on\ngrid on\naxis([x_bounds, y_bounds])\naxis equal\n\n% Plot obstacles\nfor i = 1:size(obstacles, 1)\n    viscircles(obstacles(i, 1:2), obstacles(i, 3), 'Color', [0.5, 0.5, 0.5]);\nend\n\n% Initialize tree\ntheta_start.parent = 0;\nG(1) = theta_start;\n\n% Main RRT loop\nfor idx = 1:N\n    if norm(G(end).coord - theta_goal) < epsilon\n        break\n    end\n\n    % Random sample\n    theta_rand = rand(2,1);\n\n    % Nearest node\n    [min_dist, theta_near_index] = min(vecnorm([G.coord] - theta_rand));\n    theta_near = G(theta_near_index);\n\n    % Step towards random sample\n    vec_to_rand = theta_rand - theta_near.coord;\n    if norm(vec_to_rand) > delta\n        vec_to_rand = delta * vec_to_rand / norm(vec_to_rand);\n    end\n    theta_new.coord = theta_near.coord + vec_to_rand;\n\n    % Collision check with all obstacles\n    if isCollision(theta_new.coord, obstacles)\n        continue;\n    end\n\n    % Add new node to tree\n    theta_new.parent = theta_near_index;\n    G = [G, theta_new];\n\n    % Plotting\n    plot(theta_new.coord(1), theta_new.coord(2), 'o', 'Color', [0.5, 0.5, 0.5], ...\n    'MarkerFaceColor', [0.5, 0.5, 0.5]);\n    line([theta_near.coord(1), theta_new.coord(1)], [theta_near.coord(2), theta_new.coord(2)], 'Color', 'k', 'LineWidth', 2);\nend\n\n% Trace back path\nchild_theta = G(end);\nwhile child_theta.parent ~= 0\n    parent_theta = G(child_theta.parent);\n    line([child_theta.coord(1), parent_theta.coord(1)], [child_theta.coord(2), parent_theta.coord(2)], 'Color', [1, 0.5, 0], 'LineWidth', 3);\n    child_theta = parent_theta;\nend\n\n% Plot start and goal\nplot(theta_start.coord(1), theta_start.coord(2), 'ko', 'MarkerFaceColor', 'k');\nplot(theta_goal(1), theta_goal(2), 'ko', 'MarkerFaceColor', 'k');\n\n% Collision checking function\n\nfunction collision = isCollision(coord, obstacles)\n    collision = any(arrayfun(@(idx) norm(coord - obstacles(idx, 1:2)') < obstacles(idx, 3), 1:size(obstacles, 1)));\nend\n```\n</details>\n\n**Result**\n\n<img src=\"RRT_main.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\n\n\nNotice that centers is a matrix where each column corresponds to an obstacle center. Similarly, radii is a vector where the ùëñ-th entry corresponds to the radius of the ùëñ-th obstacle.\n\n * **Environment 1: One obstacle with center ùëê1 = [0.55, 0.5]^ùëá and radius ùëü1 = 0.3.**\n\n\n**RRT Algorithm for 1 Obstacle**\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom matplotlib.animation import PillowWriter, FuncAnimation\n\n# Environment\ntheta_start = {'coord': np.array([0, 0])}\ntheta_goal = {'coord': np.array([1, 1])}\ncenters = np.array([[0.5], [0.5]])\nradii = np.array([0.3])\n\n# Parameters\nepsilon = 0.1\ndelta = 0.1\nN = 1000\n\n# Initialize figure\nfig, ax = plt.subplots()\nax.grid(True)\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_aspect('equal', adjustable='box')\n\n# Draw obstacles\n\nfor idx in range(len(radii)):\n    circle = Circle(centers[:, idx], radii[idx], color=[0.5, 0.5, 0.5], alpha=0.7)\n    ax.add_patch(circle)\n\n# Plot start and goal\nax.plot(0, 0, 'ko', markerfacecolor='k')\nax.plot(1, 1, 'ko', markerfacecolor='k')\n\n# Initialize tree\ntheta_start['parent'] = None\nG = [theta_start]\nfinal_path_plotted = False\n\ndef update(frame):\n    global G, final_path_plotted\n    if frame == 0 or final_path_plotted:\n        return\n\n    # Sample random joint position\n    theta_rand = np.random.rand(2)\n\n    # Find node in G nearest to theta_rand\n    dist = [np.linalg.norm(node['coord'] - theta_rand) for node in G]\n    theta_near_index = np.argmin(dist)\n    theta_near = G[theta_near_index]\n\n    # Take a step from theta_near towards theta_rand\n    vec_to_rand = theta_rand - theta_near['coord']\n    dist_to_rand = np.linalg.norm(vec_to_rand)\n\n    theta_new = {}\n    if dist_to_rand < delta:\n        theta_new['coord'] = theta_rand\n    else:\n        theta_new['coord'] = theta_near['coord'] + delta * vec_to_rand / dist_to_rand\n\n    # Check if theta_new is collision-free\n    collision = False\n    for jdx in range(len(radii)):\n        center = centers[:, jdx]\n        radius = radii[jdx]\n        if np.linalg.norm(theta_new['coord'] - center) < radius:\n            collision = True\n            break\n\n    if collision:\n        return\n\n    # If collision-free, add theta_new to tree with parent theta_near\n    theta_new['parent'] = theta_near_index\n    G.append(theta_new)\n\n    # Plot node and edge\n    ax.plot(theta_new['coord'][0], theta_new['coord'][1], 'o', color=[0.5, 0.5, 0.5], markerfacecolor=[0.5, 0.5, 0.5])\n    ax.plot([theta_near['coord'][0], theta_new['coord'][0]], [theta_near['coord'][1], theta_new['coord'][1]], 'k-', linewidth=2)\n\n    # If goal is close enough to the last node in G, plot the final path\n    if np.linalg.norm(G[-1]['coord'] - theta_goal['coord']) < epsilon:\n        next_theta = G[-1]\n        while next_theta['parent'] is not None:\n            prev_theta = G[next_theta['parent']]\n            line, = ax.plot([next_theta['coord'][0], prev_theta['coord'][0]], [next_theta['coord'][1], prev_theta['coord'][1]], 'orange', linewidth=3)\n            next_theta = prev_theta\n\n        # Add final path to the animation\n        final_path_plotted = True\n        return line,\n\n\n# Create the animation\nani = FuncAnimation(fig, update, frames=N, repeat=False)\n\n# Save the animation\nwriter = PillowWriter(fps=20)\nani.save(\"RRT_1_obstacles.gif\", writer=writer)\n```\n:::\n\n\n**Result:**\n\n<img src=\"RRT_1_obstacles.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\n\n* **Environment 2: One obstacle with center ùëê1 = [0.5, 0.3]^ùëá and radius ùëü1 = 0.3. A second obstacle with center ùëê2 = [0.5, 0.7]^ùëá and radius ùëü2 = 0.2.**\n\n**RRT Algorithm for 2 Obstacles**\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom matplotlib.animation import PillowWriter, FuncAnimation\n\n# Environment\ntheta_start = {'coord': np.array([0, 0])}\ntheta_goal = {'coord': np.array([1, 1])}\ncenters = np.array([[0.5, 0.3], [0.5, 0.7]])\nradii = np.array([0.3, 0.2])\n\n# Parameters\nepsilon = 0.1\ndelta = 0.1\nN = 1000\n\n# Initialize figure\nfig, ax = plt.subplots()\nax.grid(True)\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_aspect('equal', adjustable='box')\n\n# Draw obstacles\n\nfor idx in range(len(radii)):\n    circle = Circle(centers[:, idx], radii[idx], color=[0.5, 0.5, 0.5], alpha=0.7)\n    ax.add_patch(circle)\n\n# Plot start and goal\nax.plot(0, 0, 'ko', markerfacecolor='k')\nax.plot(1, 1, 'ko', markerfacecolor='k')\n\n# Initialize tree\ntheta_start['parent'] = None\nG = [theta_start]\nfinal_path_plotted = False\n\ndef update(frame):\n    global G, final_path_plotted\n    if frame == 0 or final_path_plotted:\n        return\n\n    # Sample random joint position\n    theta_rand = np.random.rand(2)\n\n    # Find node in G nearest to theta_rand\n    dist = [np.linalg.norm(node['coord'] - theta_rand) for node in G]\n    theta_near_index = np.argmin(dist)\n    theta_near = G[theta_near_index]\n\n    # Take a step from theta_near towards theta_rand\n    vec_to_rand = theta_rand - theta_near['coord']\n    dist_to_rand = np.linalg.norm(vec_to_rand)\n\n    theta_new = {}\n    if dist_to_rand < delta:\n        theta_new['coord'] = theta_rand\n    else:\n        theta_new['coord'] = theta_near['coord'] + delta * vec_to_rand / dist_to_rand\n\n    # Check if theta_new is collision-free\n    collision = False\n    for jdx in range(len(radii)):\n        center = centers[:, jdx]\n        radius = radii[jdx]\n        if np.linalg.norm(theta_new['coord'] - center) < radius:\n            collision = True\n            break\n\n    if collision:\n        return\n\n    # If collision-free, add theta_new to tree with parent theta_near\n    theta_new['parent'] = theta_near_index\n    G.append(theta_new)\n\n    # Plot node and edge\n    ax.plot(theta_new['coord'][0], theta_new['coord'][1], 'o', color=[0.5, 0.5, 0.5], markerfacecolor=[0.5, 0.5, 0.5])\n    ax.plot([theta_near['coord'][0], theta_new['coord'][0]], [theta_near['coord'][1], theta_new['coord'][1]], 'k-', linewidth=2)\n\n    # If goal is close enough to the last node in G, plot the final path\n    if np.linalg.norm(G[-1]['coord'] - theta_goal['coord']) < epsilon:\n        next_theta = G[-1]\n        while next_theta['parent'] is not None:\n            prev_theta = G[next_theta['parent']]\n            line, = ax.plot([next_theta['coord'][0], prev_theta['coord'][0]], [next_theta['coord'][1], prev_theta['coord'][1]], 'orange', linewidth=3)\n            next_theta = prev_theta\n\n        # Add final path to the animation\n        final_path_plotted = True\n        return line,\n\n\n# Create the animation\nani = FuncAnimation(fig, update, frames=N, repeat=False)\n\n# Save the animation\nwriter = PillowWriter(fps=20)\nani.save(\"RRT_2_obstacles.gif\", writer=writer)\n```\n:::\n\n\n**Result:**\n\n<img src=\"RRT_2_obstacles.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\n\n* **Environment 3: One obstacle with center ùëê1 = [0.2, 0.35]^ùëá and radius ùëü1 = 0.2. A second obstacle with center ùëê2 = [0.5, 0.3]^ùëá and radius ùëü2 = 0.2. A third obstacle with center ùëê3 = [0.7, 0.5]^ùëá and radius ùëü3 = 0.2.**\n\nHere we are declaring it a Baseline Algorithm for 3 obstacles. Later below we will discuss the differences between a baseline and Goal-bias algorithm and their pros-cons.\n\n**Baseline RRT Algorithm**\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom matplotlib.animation import PillowWriter, FuncAnimation\n\n# Environment\ntheta_start = {'coord': np.array([0, 0])}\ntheta_goal = {'coord': np.array([1, 1])}\ncenters = np.array([[0.2, 0.5, 0.7], [0.35, 0.3, 0.5]])\nradii = np.array([0.2, 0.2, 0.2])\n\n# Parameters\nepsilon = 0.1\ndelta = 0.1\nN = 1000\n\n# Initialize figure\nfig, ax = plt.subplots()\nax.grid(True)\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_aspect('equal', adjustable='box')\n\n# Draw obstacles\n\nfor idx in range(len(radii)):\n    circle = Circle(centers[:, idx], radii[idx], color=[0.5, 0.5, 0.5], alpha=0.7)\n    ax.add_patch(circle)\n\n# Plot start and goal\nax.plot(0, 0, 'ko', markerfacecolor='k')\nax.plot(1, 1, 'ko', markerfacecolor='k')\n\n# Initialize tree\ntheta_start['parent'] = None\nG = [theta_start]\nfinal_path_plotted = False\n\ndef update(frame):\n    global G, final_path_plotted\n    if frame == 0 or final_path_plotted:\n        return\n\n    # Sample random joint position\n    theta_rand = np.random.rand(2)\n\n    # Find node in G nearest to theta_rand\n    dist = [np.linalg.norm(node['coord'] - theta_rand) for node in G]\n    theta_near_index = np.argmin(dist)\n    theta_near = G[theta_near_index]\n\n    # Take a step from theta_near towards theta_rand\n    vec_to_rand = theta_rand - theta_near['coord']\n    dist_to_rand = np.linalg.norm(vec_to_rand)\n\n    theta_new = {}\n    if dist_to_rand < delta:\n        theta_new['coord'] = theta_rand\n    else:\n        theta_new['coord'] = theta_near['coord'] + delta * vec_to_rand / dist_to_rand\n\n    # Check if theta_new is collision-free\n    collision = False\n    for jdx in range(len(radii)):\n        center = centers[:, jdx]\n        radius = radii[jdx]\n        if np.linalg.norm(theta_new['coord'] - center) < radius:\n            collision = True\n            break\n\n    if collision:\n        return\n\n    # If collision-free, add theta_new to tree with parent theta_near\n    theta_new['parent'] = theta_near_index\n    G.append(theta_new)\n\n    # Plot node and edge\n    ax.plot(theta_new['coord'][0], theta_new['coord'][1], 'o', color=[0.5, 0.5, 0.5], markerfacecolor=[0.5, 0.5, 0.5])\n    ax.plot([theta_near['coord'][0], theta_new['coord'][0]], [theta_near['coord'][1], theta_new['coord'][1]], 'k-', linewidth=2)\n\n    # If goal is close enough to the last node in G, plot the final path\n    if np.linalg.norm(G[-1]['coord'] - theta_goal['coord']) < epsilon:\n        next_theta = G[-1]\n        while next_theta['parent'] is not None:\n            prev_theta = G[next_theta['parent']]\n            line, = ax.plot([next_theta['coord'][0], prev_theta['coord'][0]], [next_theta['coord'][1], prev_theta['coord'][1]], 'orange', linewidth=3)\n            next_theta = prev_theta\n\n        # Add final path to the animation\n        final_path_plotted = True\n        return line,\n\n\n# Create the animation\nani = FuncAnimation(fig, update, frames=N, repeat=False)\n\n# Save the animation\nwriter = PillowWriter(fps=20)\nani.save(\"Baseline_RRT.gif\", writer=writer)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\bhara\\AppData\\Local\\Temp\\ipykernel_3292\\592816222.py:104: UserWarning: FigureCanvasAgg is non-interactive, and thus cannot be shown\n  plt.show()\n```\n:::\n:::\n\n\n**MATLAB Implementation**\n\n<details>\n\n\n```{matlab}\nclear\nclose all\n\n% environment\ntheta_start.coord = [0; 0];\ntheta_goal.coord = [1; 1];\ncenters = [0.2, 0.5, 0.7; 0.35, 0.3, 0.5];\nradii = [0.2, 0.2, 0.2];\n\n% parameters\nepsilon = 0.1;\ndelta = 0.1;\nN = 1000;\n\n% visualize environment\nfigure\ngrid on\nhold on\naxis([0, 1, 0, 1])\naxis equal\n\nfor idx = 1:length(radii)\n viscircles(centers(:, idx)', radii(idx), 'Color', [0.5, 0.5, ...\n 0.5]);\nend\n\nplot(0, 0, 'ko', 'MarkerFaceColor', 'k')\nplot(1, 1, 'ko', 'MarkerFaceColor', 'k')\n\n% initialize tree\ntheta_start.parent = 0;\nG(1) = theta_start;\n\nfor idx = 1:N\n % stop if theta_new is close to theta_goal\n if norm(G(end).coord - theta_goal.coord) < epsilon\n break\n end\n\n % sample random joint position\n theta_rand = rand(2,1);\n\n % find node in G nearest to theta_rand\n dist = zeros(length(G), 1);\n for jdx = 1:1:length(G)\n dist(jdx) = norm(G(jdx).coord - theta_rand);\n end\n [~, theta_near_index] = min(dist);\n theta_near = G(theta_near_index);\n\n % take a step from theta_near towards theta_rand\n vec_to_rand = theta_rand - theta_near.coord;\n dist_to_rand = norm(vec_to_rand);\n\n if dist_to_rand < delta\n theta_new.coord = theta_rand;\n else\n theta_new.coord = theta_near.coord + delta * ...\n vec_to_rand/dist_to_rand;\n end\n\n % check if theta_new is collision free\n collision = false;\n for jdx = 1:length(radii)\n center = centers(:, jdx);\n radius = radii(jdx);\n if norm(theta_new.coord - center) < radius\n collision = true;\n end\n end\n\n if collision\n continue\n end\n\n % if collision free, add theta_new to tree with parent theta_near\n theta_new.parent = theta_near_index;\n G = [G, theta_new];\n\n % plot node and edge\n plot(theta_new.coord(1), theta_new.coord(2), 'o', 'Color', [0.5, ...\n 0.5, 0.5], 'MarkerFaceColor', [0.5, 0.5, 0.5])\n line([theta_near.coord(1), theta_new.coord(1)], ...\n [theta_near.coord(2), theta_new.coord(2)], 'Color', 'k', 'LineWidth', ...\n 2);\nend\n\n% work backwards from the final node to the root of the tree\nnext_theta = G(end);\nwhile next_theta.parent ~= 0\n prev_theta_idx = next_theta.parent;\n prev_theta = G(prev_theta_idx);\n line([next_theta.coord(1), prev_theta.coord(1)], ...\n [next_theta.coord(2), prev_theta.coord(2)], 'Color', [1, 0.5, ...\n 0], 'LineWidth', 3);\n next_theta = prev_theta;\nend\n```\n\n\n</details>\n\n**Result:**\n\n<img src=\"Baseline_RRT.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\n\nWe can see the trajectory plots in the above figures. Here the black lines and gray dots show the tree ùê∫, while the orange line is the final motion plan from ùúÉùë†ùë°ùëéùëüùë° to a point close to the goal (ùúñ ‚â§ 0.1). Each time we run your RRT code you should get a different solution: RRT builds the tree through random sampling.\n\n\n## Goal-Bias RRT Algorithm\n\nThis version will sample the goal more frequently (let‚Äôs refer to this as goal bias). For goal bias, with probability 0.2 set ùúÉùëüùëéùëõùëë as ùúÉùëîùëúùëéùëô. Otherwise sample randomly as normal. Run your code 10 times for baseline and 10 times for goal bias. Write down how many samples it takes on average to find a motion plan. Which approach is more sample-efficient: baseline or goal bias? \n\nLet us check the implementation and results.\n\n**Goal-Bias RRT Implementation**\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib\nmatplotlib.use('Agg')  # Set the backend to a non-interactive backend\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\nfrom matplotlib.animation import PillowWriter, FuncAnimation\n\n# Environment\ntheta_start = {'coord': np.array([0, 0])}\ntheta_goal = {'coord': np.array([1, 1])}\ncenters = np.array([[0.2, 0.5, 0.7], [0.35, 0.3, 0.5]])\nradii = np.array([0.2, 0.2, 0.2])\n\n# Parameters\nepsilon = 0.1\ndelta = 0.1\nN = 1000\n\n# Initialize figure\nfig, ax = plt.subplots()\nax.grid(True)\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_aspect('equal', adjustable='box')\n\n# Draw obstacles\nfor idx in range(len(radii)):\n    circle = Circle(centers[:, idx], radii[idx], color=[0.5, 0.5, 0.5], alpha=0.7)\n    ax.add_patch(circle)\n\n# Plot start and goal\nax.plot(0, 0, 'ko', markerfacecolor='k')\nax.plot(1, 1, 'ko', markerfacecolor='k')\n\n# Initialize tree\ntheta_start['parent'] = None\nG = [theta_start]\nfinal_path_plotted = False\n\ndef update(frame):\n    global G, final_path_plotted\n    if frame == 0 or final_path_plotted:\n        return\n\n    # Sample random joint position\n    if np.random.rand() < 0.2:\n        theta_rand = theta_goal['coord']\n    else:\n        theta_rand = np.random.rand(2)\n\n\n    # Find node in G nearest to theta_rand\n    dist = [np.linalg.norm(node['coord'] - theta_rand) for node in G]\n    theta_near_index = np.argmin(dist)\n    theta_near = G[theta_near_index]\n\n    # Take a step from theta_near towards theta_rand\n    vec_to_rand = theta_rand - theta_near['coord']\n    dist_to_rand = np.linalg.norm(vec_to_rand)\n\n    theta_new = {}\n    if dist_to_rand < delta:\n        theta_new['coord'] = theta_rand\n    else:\n        theta_new['coord'] = theta_near['coord'] + delta * vec_to_rand / dist_to_rand\n\n    # Check if theta_new is collision-free\n    collision = False\n    for jdx in range(len(radii)):\n        center = centers[:, jdx]\n        radius = radii[jdx]\n        if np.linalg.norm(theta_new['coord'] - center) < radius:\n            collision = True\n            break\n\n    if collision:\n        return\n\n    # If collision-free, add theta_new to tree with parent theta_near\n    theta_new['parent'] = theta_near_index\n    G.append(theta_new)\n\n    # Plot node and edge\n    ax.plot(theta_new['coord'][0], theta_new['coord'][1], 'o', color=[0.5, 0.5, 0.5], markerfacecolor=[0.5, 0.5, 0.5])\n    ax.plot([theta_near['coord'][0], theta_new['coord'][0]], [theta_near['coord'][1], theta_new['coord'][1]], 'k-', linewidth=2)\n\n    # If goal is close enough to the last node in G, plot the final path\n    if np.linalg.norm(G[-1]['coord'] - theta_goal['coord']) < epsilon:\n        next_theta = G[-1]\n        while next_theta['parent'] is not None:\n            prev_theta = G[next_theta['parent']]\n            line, = ax.plot([next_theta['coord'][0], prev_theta['coord'][0]], [next_theta['coord'][1], prev_theta['coord'][1]], 'orange', linewidth=3)\n            next_theta = prev_theta\n\n        # Add final path to the animation\n        final_path_plotted = True\n        return line,\n\n\n# Create the animation\nani = FuncAnimation(fig, update, frames=N, repeat=False)\n\n# Save the animation\nwriter = PillowWriter(fps=20)\nani.save(\"Goal_bias_RRT.gif\", writer=writer)\n```\n:::\n\n\n**MATLAB Implementation**\n\n<details>\n\n\n```{matlab}\nclear\nclose all\n% Environment initiation\ntheta_start.coord = [0; 0];\ntheta_goal = [1; 1];\n\n% Obstacle Parameters\n% First obstacle center and radius\ncenter = [0.2; 0.35];\nradius = 0.2;\n% Second obstacle center and radius\ncenter2 = [0.5; 0.3]; \nradius2 = 0.2;\n% Third obstacle center and radius\ncenter3 = [0.7; 0.5];\nradius3 = 0.2;\n\n% Specifying parameters\nepsilon = 0.1;\ndelta = 0.1;\nN = 1000;\n\n% Visualizing the environment\nfigure\ngrid on\nhold on\naxis([0, 1, 0, 1])\naxis equal\nviscircles(center', radius, 'Color', [0.5, 0.5, 0.5]);\nviscircles(center2', radius2, 'Color', [0.7, 0.3, 0.3]); % Visualizing the second obstacle\nviscircles(center3', radius3, 'Color', [0.3, 0.5, 0.7]); % Visualizing the third obstacle\nplot(0, 0, 'ko', 'MarkerFaceColor', 'k')\nplot(1, 1, 'ko', 'MarkerFaceColor', 'k')\n\n% Initializing the tree\ntheta_start.parent = 0;\nG(1) = theta_start;\n\nfor idx = 1:N\n    \n    % Stop if the last node in G is close to theta_goal\n    if norm(G(end).coord  - theta_goal) < epsilon\n        break\n    end\n\n    % sample random joint position: probability 0.2\n    \n    if rand() < 0.2\n        theta_rand = theta_goal;\n    else\n        theta_rand = rand(2,1);\n    end\n    \n    % find node in G nearest to theta_rand\n    min_dist = inf;\n    theta_near_index = 0;\n\n    for jdx = 1:length(G)\n        coord = G(jdx).coord;\n        dist = norm(theta_rand - coord);\n        if dist < min_dist\n            min_dist = dist;\n            theta_near_index = jdx;\n        end\n    end\n\n    theta_near = G(theta_near_index);\n    % take a step from theta_near towards theta_rand\n    vec_to_rand = theta_rand - theta_near.coord;\n    dist_to_rand = norm(vec_to_rand);\n    if dist_to_rand < delta\n        theta_new.coord = theta_rand;\n    else\n        theta_new.coord = theta_near.coord + delta * ...\n        vec_to_rand/dist_to_rand;\n    end\n    \n    % check if theta_new is collision free with all obstacles\n    dist_to_obs1 = norm(theta_new.coord - center);\n    dist_to_obs2 = norm(theta_new.coord - center2);\n    dist_to_obs3 = norm(theta_new.coord - center3);\n    if dist_to_obs1 < radius || dist_to_obs2 < radius2 || dist_to_obs3 < radius3\n        continue\n    end\n\n    % if collision free, add theta_new to tree with parent theta_near\n    theta_new.parent = theta_near_index;\n    G = [G, theta_new];\n\n    % plot node and edge\n    plot(theta_new.coord(1), theta_new.coord(2), 'o', 'Color', [0.5, 0.5, 0.5], ...\n    'MarkerFaceColor', [0.5, 0.5, 0.5])\n    line([theta_near.coord(1), theta_new.coord(1)], [theta_near.coord(2), ...\n    theta_new.coord(2)], 'Color', 'k', 'LineWidth', 2);\n    drawnow\n\nend\n\n% work backwards from the final node to the root of the tree\nchild_theta = G(end);\nwhile child_theta.parent ~= 0\n\n    parent_theta_index = child_theta.parent;\n    parent_theta = G(parent_theta_index);\n    line([child_theta.coord(1), parent_theta.coord(1)], ...\n        [child_theta.coord(2), parent_theta.coord(2)], ...\n        'Color', [1, 0.5, 0], 'LineWidth', 3);\n    child_theta = parent_theta;\nend\n```\n\n\n</details>\n\n**Result:**\n\n<img src=\"Goal_bias_RRT.gif\" alt=\"Animated GIF\" loop width=\"100%\" height=\"100%\">\n\n\n\nThe samples ùëÅ across ten runs with baseline and goal bias are tabulated below.\n\n\n| run  | baseline | goal bias|\n|------|----------|----------|\n| 1    |   254    |   225    |\n| 2    |   363    |   169    |\n| 3    |   318    |   150    |\n| 4    |   590    |   143    |\n| 5    |   352    |   249    |\n| 6    |   359    |   166    |\n| 7    |   202    |   251    |\n| 8    |   267    |   162    |\n| 9    |   440    |   183    |\n| 10   |   226    |   313    |\n\n\n\nOn average, the **baseline** required **337** samples to reach a valid motion plan, while **goal bias** needed **201** samples. For **Environment 3** the evidence suggests that biasing the samples towards ùúÉùëîùëúùëéùëô decreases the total number of samples and causes RRT to reach a solution faster. Intuitively, this is because the tree is trying to move in the direction of the goal more frequently. \n\nThis is particularly advantageous when the robot is in free space (or has passed the obstacles) and should move directly towards the goal. The code snippet required to implement goal bias is shown below:\n\n**Python version**\n\n```python\n# Sample random joint position: probability 0.2\nif np.random.rand() < 0.2:\n    theta_rand = theta_goal['coord']\nelse:\n    theta_rand = np.random.rand(2)\n```\n**MATLAB version**\n\n<details>\n\n```matlab\n% sample random joint position: probability 0.2\n    \nif rand() < 0.2\n    theta_rand = theta_goal;\nelse\n    theta_rand = rand(2,1);\nend\n```\n</details>\n\n\n\n**Sample Efficiency Comparison:**\n\n‚Ä¢ Goal-biased RRT seemed to be more sample-efficient in open or less complex environments because it directs its exploration towards the goal, thereby potentially finding a path with fewer samples.\n\n‚Ä¢ In contrast, the baseline RRT might be more effective in highly cluttered environments where a direct path to the goal is less likely, and a more uniform exploration of the space is beneficial.\n\nWe need to understand the key differences between the two methods and their impact on sample efficiency:\n\n* Baseline RRT: This approach uniformly samples the entire configuration space without any bias towards the goal. It explores the space in a more scattered manner, which can be beneficial in complex environments with many obstacles. However, it might take more samples to find a path to the goal, especially in large or open spaces, because the sampling is entirely random and not directed towards the goal.\n    \n* Goal-Biased RRT: In this approach, the algorithm is biased to sample near the goal state more frequently. This bias can significantly reduce the number of samples required to find a path to the goal in many cases, especially in less complex environments or when the goal is not surrounded by obstacles. The downside is that in highly cluttered environments, this bias might lead to more samples being wasted near the goal where paths are infeasible.\n\n\n\n\n\n\n\n```{=html}\n<script>\nconst tooltipTriggerList = document.querySelectorAll('[data-bs-toggle=\"tooltip\"]')\nconst tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))\n</script>\n<style>\ndiv#quarto-sidebar-glass { display: none !important; }\nul.navbar-nav.navbar-nav-scroll { -webkit-flex-direction: row !important; }\n/* #quarto-sidebar { padding: 5px; }\n#quarto-sidebar > * { padding: 5px; }\ndiv.sidebar-menu-container > * { padding: 5px 5px 5px 5px; }\n#quarto-margin-sidebar { padding: 40px; } */\n</style>\n```\n\n",
    "supporting": [
      "Robotics_files"
    ],
    "filters": [],
    "includes": {}
  }
}